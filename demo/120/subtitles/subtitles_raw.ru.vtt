WEBVTT

00:00:00.000 --> 00:00:02.880
Добрый день, уважаемые студенты!

00:00:02.880 --> 00:00:06.120
Я рад вас всех видеть на очередной сессии демо.

00:00:06.120 --> 00:00:09.680
Сегодня мы с вами проделаем абсолютно то же задание,

00:00:09.680 --> 00:00:13.160
что и предыдущее демо, то есть создадим VPC и все

00:00:13.160 --> 00:00:16.640
ее необходимые компоненты в облаке AWS.

00:00:16.640 --> 00:00:19.460
Отличие лишь в том, что мы будем для этого использовать

00:00:19.460 --> 00:00:24.960
не AWS Management Console, а AWS CLI, то есть командную строку для

00:00:24.960 --> 00:00:27.280
работы с облаком AWS.

00:00:27.280 --> 00:00:32.200
Итак, давайте начнем.

00:00:32.200 --> 00:00:34.400
Давайте вспомним какое же было задание.

00:00:34.400 --> 00:00:39.920
Необходимо было в AWS аккаунте создать в регионе Норс-Вирджиния

00:00:39.920 --> 00:00:42.680
это US East 1 VPC.

00:00:42.680 --> 00:00:48.400
VPC будет называться demo VPC с указанным CIDR блоком.

00:00:48.400 --> 00:00:53.040
Все ресурсы в VPC будут в одной availability зоне это US

00:00:53.040 --> 00:00:54.040
East 1A.

00:00:54.040 --> 00:00:58.560
В VPC у нас будет два subnet, один public, другой private.

00:00:58.560 --> 00:01:01.740
Мы с вами помним, что public subnet это лишь только название

00:01:01.740 --> 00:01:05.020
и необходимо сделать определенные шаги, чтобы он фактически

00:01:05.020 --> 00:01:06.020
стал public.

00:01:06.020 --> 00:01:10.840
Для этого у нас будут отдельные два root table, один для public

00:01:10.840 --> 00:01:13.800
subnet, другой для private subnet.

00:01:13.800 --> 00:01:17.680
Мы подключим интернет gateway к нашему VPC, настроим NAT gateway

00:01:17.680 --> 00:01:20.680
и поработаем с elastic IP адресом.

00:01:20.680 --> 00:01:29.200
Все работы мы будем проводить в sandbox в самом конце.

00:01:29.200 --> 00:01:35.520
В нижней части списка модулей в AWS Academy вы можете найти

00:01:35.520 --> 00:01:39.280
пункт sandbox и если по нему перейдете будет аналогичный

00:01:39.280 --> 00:01:42.560
интерфейс с лабораторной работой.

00:01:42.560 --> 00:01:48.040
Здесь нам необходимо будет открыть окно терминала

00:01:48.040 --> 00:01:53.400
и далее стартовать лабораторную работу, чтобы для нас создался

00:01:53.400 --> 00:01:55.400
временный AWS account.

00:01:55.400 --> 00:01:57.680
Как только вы ее нажмете необходимо будет подождать

00:01:57.680 --> 00:02:01.080
некоторое время, после чего статус лабораторной

00:02:01.080 --> 00:02:02.760
работы перейдет в ready.

00:02:02.760 --> 00:02:05.860
Мы можем закрывать это всплывающее окно и после того как вы

00:02:05.860 --> 00:02:11.280
нажмете на кнопку AWS вас направить на AWS Management Console.

00:02:11.280 --> 00:02:13.900
Все команды мы будем вводить на странице лабораторной

00:02:13.900 --> 00:02:24.200
работе в терминале, а проверять будем позже в AWS Management Console.

00:02:24.200 --> 00:02:27.460
Мы с вами начинаем первую часть нашего демо и сейчас

00:02:27.460 --> 00:02:29.480
будем создавать VPC.

00:02:29.480 --> 00:02:32.320
Также разберем определенные нюансы при работе с командной

00:02:32.320 --> 00:02:33.600
строкой.

00:02:33.600 --> 00:02:36.760
Самая первая команда это создание VPC.

00:02:36.760 --> 00:02:39.280
VPC без дополнительных компонентов.

00:02:39.280 --> 00:02:43.320
Вы видите команду, давайте разберем команду по частям.

00:02:43.320 --> 00:02:47.200
Первая часть это ключевое слово AWS говорит о том, что

00:02:47.200 --> 00:02:50.120
мы начинаем использовать AWS CLI.

00:02:50.120 --> 00:02:53.280
Далее через пробел идет второе ключевое слово

00:02:53.280 --> 00:02:54.720
это название сервиса.

00:02:54.720 --> 00:02:58.200
В нашем случае это EC2.

00:02:58.200 --> 00:03:02.880
Третье ключевое слово это название API или операции.

00:03:02.880 --> 00:03:05.440
В нашем случае это Create VPC.

00:03:05.440 --> 00:03:13.560
Далее вы видите через двойное тире перечисленные параметры

00:03:13.560 --> 00:03:18.540
с теми значениями, которые мы хотели бы присвоить

00:03:18.540 --> 00:03:20.160
создаваемому ресурсу.

00:03:20.160 --> 00:03:25.640
В случае нашем мы создаем VPC.

00:03:25.640 --> 00:03:29.280
Первый параметр это CIDR блок с тем значением, которое

00:03:29.280 --> 00:03:32.440
мы видели на картинке в самом начале.

00:03:32.440 --> 00:03:34.960
Далее второй параметр это регион.

00:03:34.960 --> 00:03:39.400
И здесь мы указываем значение регион North Virginia, US East 1.

00:03:39.400 --> 00:03:42.980
Как только вы наберете эту команду и нажмете enter

00:03:42.980 --> 00:03:45.120
вы в ответе получите JSON.

00:03:45.120 --> 00:03:48.840
Этот JSON описывает ресурс, который был создан.

00:03:48.840 --> 00:03:52.160
Вы видите, что уже присвоился VPC ID.

00:03:52.160 --> 00:03:57.720
Также видите CIDR блок, который мы с вами ввели в входных

00:03:57.720 --> 00:04:01.120
данных и другие метаданные.

00:04:01.120 --> 00:04:03.280
Давайте теперь проверим, что этот VPC действительно

00:04:03.280 --> 00:04:07.960
появился и откроем AWS Management Console.

00:04:07.960 --> 00:04:11.400
Здесь нам необходимо воспользоваться строкой поиска сервисов

00:04:11.400 --> 00:04:13.540
и начать вводить VPC.

00:04:13.540 --> 00:04:15.960
Как только вы перейдете на нужный сервис, обязательно

00:04:15.960 --> 00:04:19.440
проверьте, что вы находитесь в нужном регионе.

00:04:19.440 --> 00:04:22.860
И в левом навигационном меню необходимо воспользоваться

00:04:22.860 --> 00:04:25.560
пунктом Your VPCs.

00:04:25.560 --> 00:04:33.200
Вы увидите, что у нас создался VPC с тем же VPC ID и с CIDR блоком

00:04:33.200 --> 00:04:36.440
который мы назначили.

00:04:36.440 --> 00:04:38.040
Давайте теперь удалим этот VPC.

00:04:38.040 --> 00:04:43.600
Я бы хотел вам продемонстрировать возможности командной строки.

00:04:43.600 --> 00:04:49.920
Нам необходимо будет подтвердить удаление VPC и увидеть сообщение,

00:04:49.920 --> 00:04:51.840
что VPC действительно удалено.

00:04:51.840 --> 00:04:57.600
Мы теперь обратно переходим в командную строку и вы

00:04:57.600 --> 00:05:03.560
видите здесь, что мы результат работы команды, которая

00:05:03.560 --> 00:05:07.080
создает VPC, присваиваем переменные.

00:05:07.080 --> 00:05:10.120
Но обратите внимание, у нас добавились дополнительные

00:05:10.120 --> 00:05:11.120
параметры.

00:05:11.120 --> 00:05:13.240
Это output, которое равно текст.

00:05:13.240 --> 00:05:16.280
То есть он в виде текста возвращает результат работы

00:05:16.280 --> 00:05:17.280
команды.

00:05:17.280 --> 00:05:19.440
И второй это query, то есть фильтрация.

00:05:19.440 --> 00:05:26.520
Мы хотим в ответе вернуть значение по пути VPC.vpcID.

00:05:26.520 --> 00:05:32.520
И это значение присвоить переменной VPC.id.

00:05:32.520 --> 00:05:36.320
Далее как только команда отработает, мы можем попробовать

00:05:36.320 --> 00:05:40.320
вывести на экран значение переменной VPC ID.

00:05:40.320 --> 00:05:48.240
Вы увидите, что мы получили другой уникальный VPC ID, но

00:05:48.240 --> 00:05:52.840
с теми же параметрами, которые мы указывали в команде.

00:05:52.840 --> 00:05:56.280
Давайте теперь перейдем обратно в AWS Management Console

00:05:56.280 --> 00:05:59.320
и проверим, что действительно все корректно отработало.

00:05:59.320 --> 00:06:02.320
Мы видим, что cidr блок тот, который мы указывали, и

00:06:02.320 --> 00:06:04.400
совпадает VPC ID.

00:06:04.400 --> 00:06:07.160
Отличие этого действия от предыдущего в том, что

00:06:07.160 --> 00:06:13.040
в командной строке мы уже сохранили VPC ID в переменной

00:06:13.040 --> 00:06:16.680
и можем его использовать в следующих наших командах.

00:06:16.680 --> 00:06:21.840
Это исключает необходимость ввода различных ID-шников,

00:06:21.840 --> 00:06:26.600
исключает человеческий фактор и упрощает работу

00:06:26.600 --> 00:06:32.080
с облаком AWS через командную строку.

00:06:32.080 --> 00:06:35.320
Мы возвращаемся обратно в командную строку и давайте

00:06:35.320 --> 00:06:42.760
здесь попробуем заполнить тег с ключом name значением

00:06:42.760 --> 00:06:43.760
demo VPC.

00:06:43.760 --> 00:06:47.240
Для этого воспользуемся следующей командой.

00:06:47.240 --> 00:06:49.400
Мы воспользуемся сервисами C2.

00:06:49.400 --> 00:06:54.640
Далее у нас есть API Create Text и следующие параметры.

00:06:54.640 --> 00:06:58.280
Обратите внимание, что для параметра resources мы передаем

00:06:58.280 --> 00:07:00.440
нашу переменную VPC ID.

00:07:00.440 --> 00:07:04.680
И в параметре Text мы передаем в определенном формате,

00:07:04.680 --> 00:07:09.280
что для тега с ключом name мы хотим присвоить значение

00:07:09.280 --> 00:07:10.920
demo VPC.

00:07:10.920 --> 00:07:14.040
Как только вы запустите эту команду, если она не

00:07:14.040 --> 00:07:17.600
вернет ошибку, это говорит о том, что команда успешно

00:07:17.600 --> 00:07:18.600
отработала.

00:07:18.600 --> 00:07:22.240
Теперь, если мы вернемся обратно в AWS Management Console,

00:07:22.240 --> 00:07:26.960
мы увидим, что столбец name для нашего VPC заполнился

00:07:26.960 --> 00:07:30.040
ее значением demo VPC.

00:07:30.040 --> 00:07:33.880
Отлично, мы с вами возвращаемся обратно в командную строку

00:07:33.880 --> 00:07:39.440
и здесь бы я хотел ваше внимание обратить.

00:07:39.440 --> 00:07:43.520
Наличие тегов в ресурсе позволяет нам фильтровать

00:07:43.520 --> 00:07:46.680
и запрашивать метаданные об этих ресурсах.

00:07:46.680 --> 00:07:50.160
Пример, мы можем сейчас получить информацию о нашем

00:07:50.160 --> 00:07:57.720
VPC, отфильтровав его по тегу name и по совпадению значения

00:07:57.720 --> 00:07:58.720
demo VPC.

00:07:58.720 --> 00:08:04.520
Для этого воспользуемся API describe VPCs и введем параметр

00:08:04.520 --> 00:08:07.760
в определенном формате, который называется filters.

00:08:07.760 --> 00:08:11.240
В результате вы видите, нам вернулась JSON.

00:08:11.240 --> 00:08:17.800
Есть единственный ключ VPCs, это массив из JSON и каждый

00:08:17.800 --> 00:08:20.760
JSON описывает определенный ресурс.

00:08:20.760 --> 00:08:25.200
Так как мы фильтрах указали определенный конкретный

00:08:25.200 --> 00:08:32.000
VPC, то и в массиве был возвращен один JSON и описывает наш

00:08:32.000 --> 00:08:33.000
VPC.

00:08:33.000 --> 00:08:39.920
Здесь бы я также хотел обратить ваше внимание, что работая

00:08:39.920 --> 00:08:42.920
с командной строкой, вы не только пишете независимые

00:08:42.920 --> 00:08:46.520
друг от друга команды, это не только про присваивание

00:08:46.520 --> 00:08:51.520
значений переменным и работе с этими переменными, вы

00:08:51.520 --> 00:08:54.240
можете писать отдельные ваш скрипты.

00:08:54.240 --> 00:08:57.560
Идея в том, что все эти команды, они могут быть объединены

00:08:57.560 --> 00:09:02.640
в одном определенном файле и этот файл выполняет определенную

00:09:02.640 --> 00:09:03.640
задачу.

00:09:03.640 --> 00:09:05.920
Не маленькую, это не одна команда, это набор из нескольких

00:09:05.920 --> 00:09:06.920
команд.

00:09:06.920 --> 00:09:11.920
В тот момент, когда вы запускаете этот ваш скрипт, то последовательно

00:09:11.920 --> 00:09:14.480
выполняются все команды из этого скрипта.

00:09:14.480 --> 00:09:19.000
Таким образом, вы через ваш скрипты можете определенную

00:09:19.000 --> 00:09:22.960
часть своей ежедневной работы, работы клауд инженера

00:09:22.960 --> 00:09:24.840
таким образом автоматизировать.

00:09:24.840 --> 00:09:27.840
Там также вы можете использовать переменные, более того,

00:09:27.840 --> 00:09:30.400
вы можете использовать более сложные конструкции,

00:09:30.400 --> 00:09:34.160
то есть циклы и файл с конструкцией и так далее.

00:09:34.160 --> 00:09:39.660
В рамках нашего дема мы с вами будем использовать

00:09:39.660 --> 00:09:40.760
простой вариант.

00:09:40.760 --> 00:09:44.780
Написание ваш скриптов не входит в рамках темы

00:09:44.780 --> 00:09:49.240
нашего дема, поэтому мы будем писать независимые

00:09:49.240 --> 00:09:54.240
команды, но при этом максимально будем стараться не привязываться

00:09:54.240 --> 00:09:58.800
к конкретным значениям, а значение ID-шники ресурсов

00:09:58.800 --> 00:10:01.860
будем присваивать переменным, чтобы потом их можно было

00:10:01.860 --> 00:10:05.640
переиспользовать.

00:10:05.640 --> 00:10:10.260
Мы с вами двигаемся к следующим компонентам нашего VPC и первым

00:10:10.260 --> 00:10:12.320
делом создадим интернет-гейтвей.

00:10:12.320 --> 00:10:15.520
Для этого мы воспользуемся следующей командой.

00:10:15.520 --> 00:10:21.080
Здесь мы сохраним значения по пути InternetGateway.InternetGatewayID

00:10:21.080 --> 00:10:24.040
в переменную IGID.

00:10:24.040 --> 00:10:29.640
Вы видите, после исполнения команды мы вывели на экран

00:10:29.640 --> 00:10:38.000
значение в переменной IGID и здесь отображается ID InternetGateway.

00:10:38.000 --> 00:10:41.200
Также мы можем перепроверить в AWS Management Console такой же

00:10:41.200 --> 00:10:45.920
ID, он появился в списке InternetGateway.

00:10:45.920 --> 00:10:49.280
Теперь нам необходимо для этого InternetGateway заполнить

00:10:49.280 --> 00:10:54.360
тег с ключом name значение demo.igv.

00:10:54.360 --> 00:10:57.640
Запускается абсолютно та же команда, которую мы

00:10:57.640 --> 00:11:01.640
запускали ранее, отличие лишь в том, что в параметр

00:11:01.640 --> 00:11:07.720
ресурсов мы передаем ID InternetGateway.

00:11:07.720 --> 00:11:10.680
Оно у нас сохранено в переменной IGID.

00:11:10.680 --> 00:11:13.640
Как только мы это сделаем, вы можете вернуться в AWS

00:11:13.640 --> 00:11:19.200
Management Console и проверить, что оно успешно применилось.

00:11:19.200 --> 00:11:20.480
Бегаемся дальше.

00:11:20.480 --> 00:11:23.560
Созданный InternetGateway теперь нам необходимо привязать

00:11:23.560 --> 00:11:24.560
к VPC.

00:11:24.560 --> 00:11:30.440
Для этого есть API Attach InternetGateway.

00:11:30.440 --> 00:11:35.280
Обязательными параметрами являются InternetGateway и VPCID.

00:11:35.280 --> 00:11:38.800
Что тот, что этот у нас сохранены в наших переменных,

00:11:38.800 --> 00:11:43.840
поэтому мы соответственно для InternetGatewayID указываем

00:11:43.840 --> 00:11:49.520
значение переменной IGID, а для VPCID переменной VPCID.

00:11:49.520 --> 00:11:54.800
После того, как вы запустите команду, в случае если не

00:11:54.800 --> 00:11:59.480
было выдано ошибки, то мы предполагаем, что команда

00:11:59.480 --> 00:12:04.080
была выполнена успешно.

00:12:04.080 --> 00:12:06.000
Теперь мы двигаемся дальше.

00:12:06.000 --> 00:12:08.920
Мы будем создавать сабнеты.

00:12:08.920 --> 00:12:11.920
Первым делом нам необходимо проверить действительно

00:12:11.920 --> 00:12:20.120
ли availability zone US East 1A существует.

00:12:20.120 --> 00:12:25.580
На самом деле это очевидно, так как мы знаем системное

00:12:25.580 --> 00:12:32.200
название региона это US East 1 и далее мы знаем, что availability

00:12:32.200 --> 00:12:37.380
zone, если их три например, то они обозначаются в алфавитном

00:12:37.380 --> 00:12:38.380
порядке.

00:12:38.380 --> 00:12:42.360
Это US East 1A, 1B и 1C.

00:12:42.360 --> 00:12:47.040
Идея этой команды была в том, что вы можете внутри

00:12:47.040 --> 00:12:53.320
программы заложить запрос существующих availability zone

00:12:53.320 --> 00:12:54.640
для указанного региона.

00:12:54.640 --> 00:12:59.400
В этом случае как в alu вы указываете не US East 1A, а US

00:12:59.400 --> 00:13:04.600
East 1 и тогда вам вернется в ответе массив availability

00:13:04.600 --> 00:13:09.560
zone с JSON, в которых будет содержаться информация

00:13:09.560 --> 00:13:11.080
каждой availability zone.

00:13:11.080 --> 00:13:13.920
Так как мы отфильтровали по нужной нам availability

00:13:13.920 --> 00:13:17.200
zone и в ответе что-то вернулось, мы для себя дополнительно

00:13:17.200 --> 00:13:25.160
подтвердили, что написание этой availability zone верное.

00:13:25.160 --> 00:13:27.680
Теперь мы будем создавать public subnet.

00:13:27.680 --> 00:13:32.920
Я не буду детально останавливаться на частях команды, так

00:13:32.920 --> 00:13:36.460
как идея она абсолютно такая же, что и в предыдущих

00:13:36.460 --> 00:13:37.460
командах.

00:13:37.460 --> 00:13:40.520
А предыдущие команды мы с вами уже подробно разобрали.

00:13:40.520 --> 00:13:44.440
Здесь мы будем использовать API create subnet, введем необходимые

00:13:44.440 --> 00:13:49.440
параметры это availability zone, cedar block и VPC ID.

00:13:49.440 --> 00:13:55.320
Далее это все мы присваиваем переменной.

00:13:55.320 --> 00:14:00.280
Нужно нам значение по пути subnet, subnet ID.

00:14:00.280 --> 00:14:04.640
Мы сразу проверяем значение в перемены public subnet ID.

00:14:04.640 --> 00:14:07.040
Есть некоторая ID.

00:14:07.040 --> 00:14:08.040
Отлично.

00:14:08.040 --> 00:14:09.040
Двигаемся дальше.

00:14:09.040 --> 00:14:12.540
Теперь нам необходимо для этого subnet заполнить

00:14:12.540 --> 00:14:15.120
тег с ключом name.

00:14:15.120 --> 00:14:18.520
Заполним значением demo public subnet.

00:14:18.520 --> 00:14:20.080
Переходим к следующему шагу.

00:14:20.080 --> 00:14:24.520
Теперь нам необходимо создать NAT gateway в нашем

00:14:24.520 --> 00:14:25.520
public subnet.

00:14:25.520 --> 00:14:28.440
Для этого в первую очередь нам необходимо создать

00:14:28.440 --> 00:14:30.600
elastic IP address.

00:14:30.600 --> 00:14:35.240
У нас есть отдельный API для создания elastic IP адресов.

00:14:35.240 --> 00:14:37.800
Называется allocate address.

00:14:37.800 --> 00:14:41.360
Здесь мы дополнительных параметров не указываем,

00:14:41.360 --> 00:14:48.600
а лишь сохраняем в переменную EIP значение в JSON по пути

00:14:48.600 --> 00:14:52.280
allocation ID.

00:14:52.280 --> 00:14:58.200
Вы видите, что в перемене EIP появился ID elastic IP адреса.

00:14:58.200 --> 00:15:01.400
Теперь мы можем двигаться дальше, а именно создадим

00:15:01.400 --> 00:15:02.400
NAT gateway.

00:15:02.400 --> 00:15:06.920
В этом случае мы используем API create NAT gateway.

00:15:06.920 --> 00:15:14.320
Передаем сюда параметры subnet ID, allocation ID и сохраняем

00:15:14.320 --> 00:15:25.560
значение по пути NAT gateway.nat gateway ID в параметр ngv ID.

00:15:25.560 --> 00:15:32.320
Другой шаг, чтобы сделать наш subnet фактически public,

00:15:32.320 --> 00:15:36.920
нам необходимо создать road table и в этом road table произвести

00:15:36.920 --> 00:15:38.600
дополнительные настройки.

00:15:38.600 --> 00:15:41.960
Итак, для создания road table мы воспользуемся API create

00:15:41.960 --> 00:15:49.120
road table, вводим параметры VPC ID и как результат в переменной

00:15:49.120 --> 00:15:55.280
public RT сохраняем значение из JSON по пути road table.road

00:15:55.280 --> 00:15:56.680
table ID.

00:15:56.680 --> 00:16:00.040
Мы видим, что в переменную записалось некоторое значение.

00:16:00.040 --> 00:16:01.040
Отлично.

00:16:01.040 --> 00:16:06.760
Теперь следующим шагом мы заполним тег с ключом

00:16:06.760 --> 00:16:12.960
name, значение будет public subnet road table и теперь для нашего

00:16:12.960 --> 00:16:18.160
road table добавим routing rule.

00:16:18.160 --> 00:16:22.400
Как мы с вами помним, нам нужно добавить routing rule,

00:16:22.400 --> 00:16:29.000
то есть как destination использует интернет и как target у нас

00:16:29.000 --> 00:16:31.680
используется интернет gateway.

00:16:31.680 --> 00:16:34.760
Соответственно мы заполняем параметры destination cidre block

00:16:34.760 --> 00:16:37.240
и gateway ID.

00:16:37.240 --> 00:16:40.880
Как только мы это все проделаем, мы получим ответ в виде

00:16:40.880 --> 00:16:51.040
JSON, где ключ return заполнен значением true.

00:16:51.040 --> 00:16:55.520
Мы сейчас создали все необходимые routing rule, теперь не забываем,

00:16:55.520 --> 00:16:59.520
что road table это отдельно независимый ресурс и чтобы

00:16:59.520 --> 00:17:03.880
он использовался, нам необходимо его привязать к subnet.

00:17:03.880 --> 00:17:07.120
Мы помним, что у каждого subnet может быть привязан

00:17:07.120 --> 00:17:12.720
только один road table, но любой road table может использоваться

00:17:12.720 --> 00:17:14.560
несколькими subnet.

00:17:14.560 --> 00:17:20.600
Окей, дальше мы будем использовать API associate road table, здесь укажем

00:17:20.600 --> 00:17:24.040
параметр road table и subnet ID.

00:17:24.040 --> 00:17:28.440
После того как мы это сделаем, мы вернем, увидим в ответе

00:17:28.440 --> 00:17:33.720
JSON, где у нас создалась ассоциация, у нее есть тоже

00:17:33.720 --> 00:17:37.120
ресурс ID, видите ее на экране.

00:17:37.120 --> 00:17:39.720
То, что мы не получили ошибку, говорит о том, что операция

00:17:39.720 --> 00:17:44.600
была успешно выполнена.

00:17:44.600 --> 00:17:47.840
Мы с вами добрались до третьей части нашего демо и будем

00:17:47.840 --> 00:17:52.880
создавать компоненты, связанные с private subnet.

00:17:52.880 --> 00:17:56.240
Первым делом нам необходимо создать этот subnet ID.

00:17:56.240 --> 00:18:01.040
Вы видите команду, мы используем API create subnet, указываем availability

00:18:01.040 --> 00:18:05.520
зону, cidr block, VPC ID и это все сохраняем в переменную

00:18:05.520 --> 00:18:06.920
private subnet ID.

00:18:06.920 --> 00:18:12.800
Из JSON мы используем значение по пути subnet.subnetID.

00:18:12.800 --> 00:18:17.480
Далее мы видим, что в переменной private subnet ID появилось значение.

00:18:17.480 --> 00:18:23.240
Теперь нам необходимо для созданного subnet ID заполнить

00:18:23.240 --> 00:18:27.680
значением ключ name.

00:18:27.680 --> 00:18:32.320
Для этого воспользуемся API create tags и введем параметры

00:18:32.320 --> 00:18:36.120
resources и tags.

00:18:36.120 --> 00:18:40.320
Далее нам необходимо создать road table, это будет private road

00:18:40.320 --> 00:18:44.080
table, используем API create road table, заполняем параметры

00:18:44.080 --> 00:18:50.560
VPC ID, у нас есть уже значение в переменной VPC ID.

00:18:50.560 --> 00:18:54.160
Далее нам необходимо протегать этот road table, чтобы мы могли

00:18:54.160 --> 00:19:00.840
его легче различать значением тега с ключом name.

00:19:00.840 --> 00:19:04.980
У нас будет private subnet road table и здесь нам необходимо

00:19:04.980 --> 00:19:09.960
будет произвести два изменения в road table.

00:19:09.960 --> 00:19:15.480
Первое это ввести routing rule, который трафик в интернет

00:19:15.480 --> 00:19:19.640
будет пропускать через созданный нами ранее NAT gateway.

00:19:19.640 --> 00:19:23.580
ID NAT gateway у нас хранится в переменной NGV ID.

00:19:23.580 --> 00:19:27.640
Как только мы запустим эту команду, мы увидим в результате

00:19:27.640 --> 00:19:34.480
JSON, где ключ return присвоено значение true.

00:19:34.480 --> 00:19:38.400
Это значит, что routing rule был успешно создан.

00:19:38.400 --> 00:19:42.520
Теперь нам необходимо этот road table привязать к private

00:19:42.520 --> 00:19:43.520
subnet.

00:19:43.520 --> 00:19:48.280
Для этого воспользуемся API associate road table, заполним

00:19:48.280 --> 00:19:56.240
road table ID, который хранится в переменной private RT и subnet

00:19:56.240 --> 00:20:01.000
ID, значение нужное лежит в переменной private subnet ID.

00:20:01.000 --> 00:20:05.440
В результате мы увидим ответ в виде JSON, где ключ

00:20:05.440 --> 00:20:10.000
association ID заполним некоторым ID, что говорит о том, что

00:20:10.000 --> 00:20:12.320
операция была успешно выполнена.

00:20:12.320 --> 00:20:13.480
Мы двигаемся дальше.

00:20:13.480 --> 00:20:17.680
Теперь нам необходимо перепроверить в AWS Management

00:20:17.680 --> 00:20:21.680
консоли, чтобы все необходимые ресурсы были созданы.

00:20:21.680 --> 00:20:25.960
Самое первое это demo VPC, совпадает с cidre block.

00:20:25.960 --> 00:20:30.080
Далее у нас есть два subnet, public subnet и private subnet.

00:20:30.080 --> 00:20:34.080
В public subnet у нас есть дополнительный routing rule, который трафик

00:20:34.080 --> 00:20:38.160
в интернет направляет через интернет gateway и есть private

00:20:38.160 --> 00:20:41.400
subnet, у нее трафик в интернет идет через NAT gateway.

00:20:41.400 --> 00:20:43.720
Здесь все верно.

00:20:43.720 --> 00:20:44.720
Двигаемся дальше.

00:20:44.720 --> 00:20:52.640
Есть у нас два road table, один для public subnet и он с ним ассоциирован

00:20:52.640 --> 00:20:56.160
и то же самое для private subnet, который ассоциирован с

00:20:56.160 --> 00:20:57.160
private subnet.

00:20:57.160 --> 00:21:01.520
Далее у нас есть один интернет gateway, который привязан

00:21:01.520 --> 00:21:03.400
к нашему demo VPC.

00:21:03.400 --> 00:21:08.160
Есть у нас elastic IP адрес, который используется NAT

00:21:08.160 --> 00:21:16.360
gateway и собственно сам NAT gateway, который вы видите,

00:21:16.360 --> 00:21:20.760
у него есть primary public IP адрес, который является elastic

00:21:20.760 --> 00:21:22.680
IP адресом.

00:21:22.680 --> 00:21:25.800
На этом мы выполнили все необходимое в рамках этого

00:21:25.800 --> 00:21:30.960
задания и фактически все те же ресурсы создали,

00:21:30.960 --> 00:21:34.560
используя командную строку.

00:21:34.560 --> 00:21:36.800
На этом мы завершаем сессию демо.

00:21:36.800 --> 00:21:40.200
Я очень надеюсь, что вам стало понятнее принципы

00:21:40.200 --> 00:21:43.240
работы в AWS CLI.

00:21:43.240 --> 00:21:45.540
Если будут вопросы, пожалуйста задавайте.

00:21:45.540 --> 00:21:47.560
На этом спасибо за внимание.

00:21:47.560 --> 00:22:04.840
Увидимся с вами на следующих наших активностях.