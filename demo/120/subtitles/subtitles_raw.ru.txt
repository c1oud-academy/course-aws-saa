 Добрый день, уважаемые студенты! Я рад вас всех видеть на очередной сессии демо. Сегодня мы с вами проделаем абсолютно то же задание, что и предыдущее демо, то есть создадим VPC и все ее необходимые компоненты в облаке AWS. Отличие лишь в том, что мы будем для этого использовать не AWS Management Console, а AWS CLI, то есть командную строку для работы с облаком AWS. Итак, давайте начнем. Давайте вспомним какое же было задание. Необходимо было в AWS аккаунте создать в регионе Норс-Вирджиния это US East 1 VPC. VPC будет называться demo VPC с указанным CIDR блоком. Все ресурсы в VPC будут в одной availability зоне это US East 1A. В VPC у нас будет два subnet, один public, другой private. Мы с вами помним, что public subnet это лишь только название и необходимо сделать определенные шаги, чтобы он фактически стал public. Для этого у нас будут отдельные два root table, один для public subnet, другой для private subnet. Мы подключим интернет gateway к нашему VPC, настроим NAT gateway и поработаем с elastic IP адресом. Все работы мы будем проводить в sandbox в самом конце. В нижней части списка модулей в AWS Academy вы можете найти пункт sandbox и если по нему перейдете будет аналогичный интерфейс с лабораторной работой. Здесь нам необходимо будет открыть окно терминала и далее стартовать лабораторную работу, чтобы для нас создался временный AWS account. Как только вы ее нажмете необходимо будет подождать некоторое время, после чего статус лабораторной работы перейдет в ready. Мы можем закрывать это всплывающее окно и после того как вы нажмете на кнопку AWS вас направить на AWS Management Console. Все команды мы будем вводить на странице лабораторной работе в терминале, а проверять будем позже в AWS Management Console. Мы с вами начинаем первую часть нашего демо и сейчас будем создавать VPC. Также разберем определенные нюансы при работе с командной строкой. Самая первая команда это создание VPC. VPC без дополнительных компонентов. Вы видите команду, давайте разберем команду по частям. Первая часть это ключевое слово AWS говорит о том, что мы начинаем использовать AWS CLI. Далее через пробел идет второе ключевое слово это название сервиса. В нашем случае это EC2. Третье ключевое слово это название API или операции. В нашем случае это Create VPC. Далее вы видите через двойное тире перечисленные параметры с теми значениями, которые мы хотели бы присвоить создаваемому ресурсу. В случае нашем мы создаем VPC. Первый параметр это CIDR блок с тем значением, которое мы видели на картинке в самом начале. Далее второй параметр это регион. И здесь мы указываем значение регион North Virginia, US East 1. Как только вы наберете эту команду и нажмете enter вы в ответе получите JSON. Этот JSON описывает ресурс, который был создан. Вы видите, что уже присвоился VPC ID. Также видите CIDR блок, который мы с вами ввели в входных данных и другие метаданные. Давайте теперь проверим, что этот VPC действительно появился и откроем AWS Management Console. Здесь нам необходимо воспользоваться строкой поиска сервисов и начать вводить VPC. Как только вы перейдете на нужный сервис, обязательно проверьте, что вы находитесь в нужном регионе. И в левом навигационном меню необходимо воспользоваться пунктом Your VPCs. Вы увидите, что у нас создался VPC с тем же VPC ID и с CIDR блоком который мы назначили. Давайте теперь удалим этот VPC. Я бы хотел вам продемонстрировать возможности командной строки. Нам необходимо будет подтвердить удаление VPC и увидеть сообщение, что VPC действительно удалено. Мы теперь обратно переходим в командную строку и вы видите здесь, что мы результат работы команды, которая создает VPC, присваиваем переменные. Но обратите внимание, у нас добавились дополнительные параметры. Это output, которое равно текст. То есть он в виде текста возвращает результат работы команды. И второй это query, то есть фильтрация. Мы хотим в ответе вернуть значение по пути VPC.vpcID. И это значение присвоить переменной VPC.id. Далее как только команда отработает, мы можем попробовать вывести на экран значение переменной VPC ID. Вы увидите, что мы получили другой уникальный VPC ID, но с теми же параметрами, которые мы указывали в команде. Давайте теперь перейдем обратно в AWS Management Console и проверим, что действительно все корректно отработало. Мы видим, что cidr блок тот, который мы указывали, и совпадает VPC ID. Отличие этого действия от предыдущего в том, что в командной строке мы уже сохранили VPC ID в переменной и можем его использовать в следующих наших командах. Это исключает необходимость ввода различных ID-шников, исключает человеческий фактор и упрощает работу с облаком AWS через командную строку. Мы возвращаемся обратно в командную строку и давайте здесь попробуем заполнить тег с ключом name значением demo VPC. Для этого воспользуемся следующей командой. Мы воспользуемся сервисами C2. Далее у нас есть API Create Text и следующие параметры. Обратите внимание, что для параметра resources мы передаем нашу переменную VPC ID. И в параметре Text мы передаем в определенном формате, что для тега с ключом name мы хотим присвоить значение demo VPC. Как только вы запустите эту команду, если она не вернет ошибку, это говорит о том, что команда успешно отработала. Теперь, если мы вернемся обратно в AWS Management Console, мы увидим, что столбец name для нашего VPC заполнился ее значением demo VPC. Отлично, мы с вами возвращаемся обратно в командную строку и здесь бы я хотел ваше внимание обратить. Наличие тегов в ресурсе позволяет нам фильтровать и запрашивать метаданные об этих ресурсах. Пример, мы можем сейчас получить информацию о нашем VPC, отфильтровав его по тегу name и по совпадению значения demo VPC. Для этого воспользуемся API describe VPCs и введем параметр в определенном формате, который называется filters. В результате вы видите, нам вернулась JSON. Есть единственный ключ VPCs, это массив из JSON и каждый JSON описывает определенный ресурс. Так как мы фильтрах указали определенный конкретный VPC, то и в массиве был возвращен один JSON и описывает наш VPC. Здесь бы я также хотел обратить ваше внимание, что работая с командной строкой, вы не только пишете независимые друг от друга команды, это не только про присваивание значений переменным и работе с этими переменными, вы можете писать отдельные ваш скрипты. Идея в том, что все эти команды, они могут быть объединены в одном определенном файле и этот файл выполняет определенную задачу. Не маленькую, это не одна команда, это набор из нескольких команд. В тот момент, когда вы запускаете этот ваш скрипт, то последовательно выполняются все команды из этого скрипта. Таким образом, вы через ваш скрипты можете определенную часть своей ежедневной работы, работы клауд инженера таким образом автоматизировать. Там также вы можете использовать переменные, более того, вы можете использовать более сложные конструкции, то есть циклы и файл с конструкцией и так далее. В рамках нашего дема мы с вами будем использовать простой вариант. Написание ваш скриптов не входит в рамках темы нашего дема, поэтому мы будем писать независимые команды, но при этом максимально будем стараться не привязываться к конкретным значениям, а значение ID-шники ресурсов будем присваивать переменным, чтобы потом их можно было переиспользовать. Мы с вами двигаемся к следующим компонентам нашего VPC и первым делом создадим интернет-гейтвей. Для этого мы воспользуемся следующей командой. Здесь мы сохраним значения по пути InternetGateway.InternetGatewayID в переменную IGID. Вы видите, после исполнения команды мы вывели на экран значение в переменной IGID и здесь отображается ID InternetGateway. Также мы можем перепроверить в AWS Management Console такой же ID, он появился в списке InternetGateway. Теперь нам необходимо для этого InternetGateway заполнить тег с ключом name значение demo.igv. Запускается абсолютно та же команда, которую мы запускали ранее, отличие лишь в том, что в параметр ресурсов мы передаем ID InternetGateway. Оно у нас сохранено в переменной IGID. Как только мы это сделаем, вы можете вернуться в AWS Management Console и проверить, что оно успешно применилось. Бегаемся дальше. Созданный InternetGateway теперь нам необходимо привязать к VPC. Для этого есть API Attach InternetGateway. Обязательными параметрами являются InternetGateway и VPCID. Что тот, что этот у нас сохранены в наших переменных, поэтому мы соответственно для InternetGatewayID указываем значение переменной IGID, а для VPCID переменной VPCID. После того, как вы запустите команду, в случае если не было выдано ошибки, то мы предполагаем, что команда была выполнена успешно. Теперь мы двигаемся дальше. Мы будем создавать сабнеты. Первым делом нам необходимо проверить действительно ли availability zone US East 1A существует. На самом деле это очевидно, так как мы знаем системное название региона это US East 1 и далее мы знаем, что availability zone, если их три например, то они обозначаются в алфавитном порядке. Это US East 1A, 1B и 1C. Идея этой команды была в том, что вы можете внутри программы заложить запрос существующих availability zone для указанного региона. В этом случае как в alu вы указываете не US East 1A, а US East 1 и тогда вам вернется в ответе массив availability zone с JSON, в которых будет содержаться информация каждой availability zone. Так как мы отфильтровали по нужной нам availability zone и в ответе что-то вернулось, мы для себя дополнительно подтвердили, что написание этой availability zone верное. Теперь мы будем создавать public subnet. Я не буду детально останавливаться на частях команды, так как идея она абсолютно такая же, что и в предыдущих командах. А предыдущие команды мы с вами уже подробно разобрали. Здесь мы будем использовать API create subnet, введем необходимые параметры это availability zone, cedar block и VPC ID. Далее это все мы присваиваем переменной. Нужно нам значение по пути subnet, subnet ID. Мы сразу проверяем значение в перемены public subnet ID. Есть некоторая ID. Отлично. Двигаемся дальше. Теперь нам необходимо для этого subnet заполнить тег с ключом name. Заполним значением demo public subnet. Переходим к следующему шагу. Теперь нам необходимо создать NAT gateway в нашем public subnet. Для этого в первую очередь нам необходимо создать elastic IP address. У нас есть отдельный API для создания elastic IP адресов. Называется allocate address. Здесь мы дополнительных параметров не указываем, а лишь сохраняем в переменную EIP значение в JSON по пути allocation ID. Вы видите, что в перемене EIP появился ID elastic IP адреса. Теперь мы можем двигаться дальше, а именно создадим NAT gateway. В этом случае мы используем API create NAT gateway. Передаем сюда параметры subnet ID, allocation ID и сохраняем значение по пути NAT gateway.nat gateway ID в параметр ngv ID. Другой шаг, чтобы сделать наш subnet фактически public, нам необходимо создать road table и в этом road table произвести дополнительные настройки. Итак, для создания road table мы воспользуемся API create road table, вводим параметры VPC ID и как результат в переменной public RT сохраняем значение из JSON по пути road table.road table ID. Мы видим, что в переменную записалось некоторое значение. Отлично. Теперь следующим шагом мы заполним тег с ключом name, значение будет public subnet road table и теперь для нашего road table добавим routing rule. Как мы с вами помним, нам нужно добавить routing rule, то есть как destination использует интернет и как target у нас используется интернет gateway. Соответственно мы заполняем параметры destination cidre block и gateway ID. Как только мы это все проделаем, мы получим ответ в виде JSON, где ключ return заполнен значением true. Мы сейчас создали все необходимые routing rule, теперь не забываем, что road table это отдельно независимый ресурс и чтобы он использовался, нам необходимо его привязать к subnet. Мы помним, что у каждого subnet может быть привязан только один road table, но любой road table может использоваться несколькими subnet. Окей, дальше мы будем использовать API associate road table, здесь укажем параметр road table и subnet ID. После того как мы это сделаем, мы вернем, увидим в ответе JSON, где у нас создалась ассоциация, у нее есть тоже ресурс ID, видите ее на экране. То, что мы не получили ошибку, говорит о том, что операция была успешно выполнена. Мы с вами добрались до третьей части нашего демо и будем создавать компоненты, связанные с private subnet. Первым делом нам необходимо создать этот subnet ID. Вы видите команду, мы используем API create subnet, указываем availability зону, cidr block, VPC ID и это все сохраняем в переменную private subnet ID. Из JSON мы используем значение по пути subnet.subnetID. Далее мы видим, что в переменной private subnet ID появилось значение. Теперь нам необходимо для созданного subnet ID заполнить значением ключ name. Для этого воспользуемся API create tags и введем параметры resources и tags. Далее нам необходимо создать road table, это будет private road table, используем API create road table, заполняем параметры VPC ID, у нас есть уже значение в переменной VPC ID. Далее нам необходимо протегать этот road table, чтобы мы могли его легче различать значением тега с ключом name. У нас будет private subnet road table и здесь нам необходимо будет произвести два изменения в road table. Первое это ввести routing rule, который трафик в интернет будет пропускать через созданный нами ранее NAT gateway. ID NAT gateway у нас хранится в переменной NGV ID. Как только мы запустим эту команду, мы увидим в результате JSON, где ключ return присвоено значение true. Это значит, что routing rule был успешно создан. Теперь нам необходимо этот road table привязать к private subnet. Для этого воспользуемся API associate road table, заполним road table ID, который хранится в переменной private RT и subnet ID, значение нужное лежит в переменной private subnet ID. В результате мы увидим ответ в виде JSON, где ключ association ID заполним некоторым ID, что говорит о том, что операция была успешно выполнена. Мы двигаемся дальше. Теперь нам необходимо перепроверить в AWS Management консоли, чтобы все необходимые ресурсы были созданы. Самое первое это demo VPC, совпадает с cidre block. Далее у нас есть два subnet, public subnet и private subnet. В public subnet у нас есть дополнительный routing rule, который трафик в интернет направляет через интернет gateway и есть private subnet, у нее трафик в интернет идет через NAT gateway. Здесь все верно. Двигаемся дальше. Есть у нас два road table, один для public subnet и он с ним ассоциирован и то же самое для private subnet, который ассоциирован с private subnet. Далее у нас есть один интернет gateway, который привязан к нашему demo VPC. Есть у нас elastic IP адрес, который используется NAT gateway и собственно сам NAT gateway, который вы видите, у него есть primary public IP адрес, который является elastic IP адресом. На этом мы выполнили все необходимое в рамках этого задания и фактически все те же ресурсы создали, используя командную строку. На этом мы завершаем сессию демо. Я очень надеюсь, что вам стало понятнее принципы работы в AWS CLI. Если будут вопросы, пожалуйста задавайте. На этом спасибо за внимание. Увидимся с вами на следующих наших активностях.
