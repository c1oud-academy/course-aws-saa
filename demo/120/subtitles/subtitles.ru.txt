Добрый день, уважаемые студенты! Я рад вас всех видеть на очередной сессии Демо. Сегодня мы с вами проделаем абсолютно то же задание, что и предыдущее Демо, то есть создадим VPC и все ее необходимые компоненты в облаке AWS. Отличие лишь в том, что мы будем для этого использовать не AWS Management Console, а AWS CLI, то есть командную строку для работы с облаком AWS. Итак, давайте начнем. Давайте вспомним какое же было задание. Необходимо было в AWS аккаунте создать в регионе North Virginia, это us-east-1 VPC. VPC будет называться DEMO_VPC с указанным CIDR блоком. Все ресурсы в VPC будут в одной availability zone это us-east-1a. В VPC у нас будет два subnet, один public, другой private. Мы с вами помним, что public subnet это лишь только название и необходимо сделать определенные шаги, чтобы он фактически стал public. Для этого у нас будут отдельные два route table, один для public subnet, другой для private subnet. Мы подключим Internet gateway к VPC, настроим NAT gateway и поработаем с Elastic IP адресом. Все работы мы будем проводить в sandbox. В нижней части списка модулей в AWS Academy вы можете найти пункт Sandbox и если по нему перейдете, будет аналогичный интерфейс с лабораторной работой. Здесь нам необходимо будет открыть окно Terminal и далее стартовать лабораторную работу, чтобы для нас создался временный AWS account. Как только вы ее нажмете необходимо будет подождать некоторое время, после чего статус лабораторной работы перейдет в Ready. Мы можем закрывать это всплывающее окно и после того как вы нажмете на кнопку AWS, вас направить на AWS Management Console. Все команды мы будем вводить на странице лабораторной работы в Terminal, а проверять будем позже в AWS Management Console. Мы начинаем первую часть нашего Демо и сейчас будем создавать VPC. Также разберем определенные нюансы при работе с командной строкой. Самая первая команда - это создание VPC. VPC без дополнительных компонентов. Вы видите команду, давайте разберем команду по частям. Первая часть - это ключевое слово AWS, говорит о том, что мы начинаем использовать AWS CLI. Далее через пробел идет второе ключевое слово - это название сервиса. В нашем случае это EC2. Третье ключевое слово - это название API или операции. В нашем случае, это Create VPC. Далее, вы видите через двойное тире перечисленные параметры с теми значениями, которые мы хотели бы присвоить создаваемому ресурсу. В нашем случае мы создаем VPC. Первый параметр - это CIDR блок с тем значением, которое мы видели на картинке в самом начале. Далее, второй параметр - это регион. И здесь мы указываем значение регион North Virginia, us-east-1. Как только вы наберете эту команду и нажмете Enter, вы в ответе получите JSON. Этот JSON описывает ресурс, который был создан. Вы видите, что уже присвоился VPC ID. Также видите CIDR блок, который мы с вами ввели в входных данных и другие метаданные. Давайте проверим, что этот VPC действительно появился и откроем AWS Management Console. Здесь нам необходимо воспользоваться строкой поиска сервисов и начать вводить VPC. Как только вы перейдете на нужный сервис, проверьте, что вы находитесь в нужном регионе. И в левом навигационном меню необходимо воспользоваться пунктом Your VPCs. Вы увидите, что у нас создался VPC с тем же VPC ID и с CIDR блоком, который мы назначили. Давайте теперь удалим этот VPC. Я бы хотел вам продемонстрировать возможности командной строки. Нам необходимо будет подтвердить удаление VPC и увидеть сообщение, что VPC действительно удалено. Мы теперь обратно переходим в командную строку и вы видите здесь, что мы результат работы команды, которая создает VPC, присваиваем переменные. Обратите внимание, у нас добавились дополнительные параметры. Это output, которое равно текст. То есть он в виде текста возвращает результат работы команды. И второй это query, то есть фильтрация. Мы хотим в ответе вернуть значение по пути Vpc.VpcId. И это значение присвоить переменной vpc_id. Как только команда отработает, можем попробовать вывести на экран значение переменной VPC ID. Вы увидите, что мы получили другой уникальный VPC ID, но с теми же параметрами, которые мы указывали в команде. Давайте теперь перейдем обратно в AWS Management Console и проверим, что действительно все корректно отработало. Мы видим, что CIDR блок тот, который мы указывали, и совпадает VPC ID. Отличие этого действия от предыдущего в том, что в командной строке мы уже сохранили VPC ID в переменной и можем его использовать в следующих наших командах. Это исключает необходимость ввода различных ID-шников, исключает человеческий фактор и упрощает работу с облаком AWS через командную строку. Мы возвращаемся обратно в командную строку и давайте здесь попробуем заполнить тег с ключом Name, значением Demo VPC. Для этого воспользуемся следующей командой. Мы воспользуемся сервисом EC2. Далее у нас есть API Create Tags и следующие параметры. Обратите внимание, что для параметра Resources мы передаем нашу переменную VPC ID. И в параметре Tags мы передаем в определенном формате, что для тега с ключом Name мы хотим присвоить значение Demo VPC. Как только вы запустите эту команду, если она не вернет ошибку, это говорит о том, что команда успешно отработала. Теперь, если мы вернемся обратно в AWS Management Console, мы увидим, что столбец Name для нашего VPC заполнился, ее значение Demo VPC. Отлично, мы с вами возвращаемся обратно в командную строку и здесь я хотел бы обратить ваше внимание на следующее. Наличие тегов в ресурсе позволяет нам фильтровать и запрашивать метаданные об этих ресурсах. Пример, мы можем сейчас получить информацию о нашем VPC, отфильтровав его по тегу Name и по совпадению значения Demo VPC. Для этого воспользуемся API describe VPCs и введем параметр в определенном формате, который называется filters. В результате вы видите, нам вернулась JSON. Есть единственный ключ VPCs, это массив из JSON и каждый JSON описывает определенный ресурс. Так как мы в фильтрах указали определенный конкретный VPC, то и в массиве был возвращен один JSON и описывает наш VPC. Здесь бы я также хотел обратить ваше внимание, что работая с командной строкой, вы не только пишете независимые друг от друга команды, это не только про присваивание значений переменным и работе с этими переменными, вы можете писать отдельные bash скрипты. Идея в том, что все эти команды могут быть объединены в одном определенном файле и этот файл выполняет определенную задачу. Не маленькую, это не одна команда, это набор из нескольких команд. В тот момент, когда вы запускаете этот bash скрипт, то последовательно выполняются все команды из этого скрипта. Таким образом, вы через bash скрипты можете определенную часть своей ежедневной работы, работы Cloud инженера автоматизировать. Там также вы можете использовать переменные, более того, вы можете использовать более сложные конструкции, то есть циклы, if else конструкции и так далее. В рамках нашего Демо мы с вами будем использовать простой вариант. Написание bash скриптов не входит в рамках темы нашего Демо, поэтому мы будем писать независимые команды, но при этом максимально будем стараться не привязываться к конкретным значениям, а значение ID-шники ресурсов будем присваивать переменным, чтобы потом их можно было переиспользовать. Мы двигаемся к следующим компонентам нашего VPC и первым делом создадим Internet gateway. Для этого мы воспользуемся следующей командой. Здесь сохраним значения по пути InternetGateway. InternetGatewayId в переменную ig_id. Вы видите, после исполнения команды, мы вывели на экран значение в переменной ig_id и здесь отображается ID Internet Gateway. Также можем перепроверить в AWS Management Console такой же ID, он появился в списке Internet Gateway. Теперь нам необходимо для этого Internet Gateway заполнить тег с ключом Name значение Demo IGW. Запускается абсолютно та же команда, которую мы запускали ранее, отличие лишь в том, что в параметр Resources мы передаем ID Internet Gateway. Оно у нас сохранено в переменной ig_id. Как только мы это сделаем, вы можете вернуться в AWS Management Console и проверить, что оно успешно применилось. Двигаемся дальше. Созданный Internet Gateway теперь нам необходимо привязать к VPC. Для этого есть API Attach Internet Gateway. Обязательными параметрами являются Internet Gateway и VPC ID. Что тот, что этот у нас сохранены в наших переменных, поэтому мы соответственно для Internet Gateway ID указываем значение переменной ig_id, а для VPC ID переменной vpc_id. После того, как вы запустите команду, в случае если не было выдано ошибки, то мы предполагаем, что команда была выполнена успешно. Теперь мы двигаемся дальше. Мы будем создавать subnets. Первым делом необходимо проверить действительно ли availability zone us-east-1a существует. На самом деле это очевидно, мы знаем системное название региона это us-east-1 и далее мы знаем, что availability zone, если их три, то они обозначаются в алфавитном порядке. Это us-east-1a, 1b и 1c. Идея этой команды была в том, что вы можете внутри программы заложить запрос существующих availability zone для указанного региона. В этом случае как value вы указываете не us-east-1a, а us-east-1 и тогда вам вернется в ответе массив availability zone с JSON, в которых будет содержаться информация каждой availability zone. Так как мы отфильтровали по нужной нам availability zone и в ответе что-то вернулось, мы для себя дополнительно подтвердили, что написание этой availability zone верное. Теперь мы будем создавать public subnet. Я не буду детально останавливаться на частях команды, так как идея она абсолютно такая же, что и в предыдущих командах. А предыдущие команды мы с вами уже подробно разобрали. Здесь мы будем использовать API create subnet, введем необходимые параметры это availability zone, CIDR block и VPC ID. Далее это все мы присваиваем переменной. Нужно нам значение по пути Subnet.SubnetId. Мы сразу проверяем значение в переменной public_subnet_id. Есть некоторая ID. Отлично. Двигаемся дальше. Теперь нам необходимо для этого subnet заполнить тег с ключом name. Заполним значением Demo Public Subnet. Переходим к следующему шагу. Теперь нам необходимо создать NAT gateway в нашем public subnet. Для этого в первую очередь нам необходимо создать Elastic IP address. У нас есть отдельный API для создания Elastic IP адресов. Называется Allocate address. Здесь мы дополнительных параметров не указываем, а лишь сохраняем в переменную eip значение в JSON по пути AllocationId. Вы видите, что в переменной eip появился ID elastic IP адреса. Теперь мы можем двигаться дальше, а именно создадим NAT gateway. В этом случае мы используем API create NAT gateway. Передаем сюда параметры subnet ID, allocation ID и сохраняем значение по пути Natgateway.NatgatewayId в параметр ngw_id. Следующий шаг, чтобы сделать наш subnet фактически public, нам необходимо создать route table и в этом route table произвести дополнительные настройки. Итак, для создания route table мы воспользуемся API create route table, вводим параметры VPC ID и как результат в переменной public_rt сохраняем значение из JSON по пути RouteTable.RouteTableId. Мы видим, что в переменную записалось некоторое значение. Отлично. Теперь следующим шагом мы заполним тег с ключом name, значение будет Public Subnet RouteTable и теперь для нашего route table добавим routing rule. Как мы с вами помним, нам нужно добавить routing rule, который как destination использует интернет и как target у нас используется Internet gateway. Соответственно, мы заполняем параметры destination cidr block и gateway ID. Как только мы это все проделаем, мы получим ответ в виде JSON, где ключ Return заполнен значением true. Мы сейчас создали все необходимые routing rule, теперь не забываем, что route table это отдельно независимый ресурс и чтобы он использовался, необходимо его привязать к subnet. Мы помним, что у каждого subnet может быть привязан только один route table, но любой route table может использоваться несколькими subnet. Окей, дальше мы будем использовать API associate route table, здесь укажем параметр route table и subnet ID. После того как мы это сделаем, мы увидим в ответе JSON, где у нас создалась ассоциация, у нее есть тоже ресурс ID, видите ее на экране. То, что мы не получили ошибку, говорит о том, что операция была успешно выполнена. Мы добрались до третьей части нашего Демо и будем создавать компоненты, связанные с private subnet. Первым делом нам необходимо создать этот subnet ID. Вы видите команду, мы используем API create subnet, указываем availability zone, CIDR block, VPC ID и это все сохраняем в переменную private_subnet_id. Из JSON мы используем значение по пути Subnet.SubnetId. Далее мы видим, что в переменной private_subnet_id появилось значение. Теперь нам необходимо для созданного subnet ID заполнить значение ключ name. Для этого воспользуемся API create tags и введем параметры resources и tags. Далее нам необходимо создать route table, это будет private route table, используем API create route table, заполняем параметры VPC ID, у нас есть уже значение в переменной vpc_id. Далее необходимо протегать этот route table, чтобы мы могли его различать. Значением тега с ключом name будет private subnet route table и здесь необходимо произвести два изменения в route table. Первое - это ввести routing rule, который трафик в интернет будет пропускать через созданный нами ранее NAT gateway. ID NAT gateway у нас хранится в переменной ngw_id. Как только мы запустим эту команду, мы увидим в результате JSON, где ключ Return присвоено значение true. Это значит, что routing rule был успешно создан. Теперь нам необходимо этот route table привязать к private subnet. Для этого воспользуемся API associate route table, заполним route table ID, который хранится в переменной private_rt и subnet ID, значение нужное лежит в переменной private_subnet_id. В результате мы увидим ответ в виде JSON, где ключ association ID заполним некоторым ID, что говорит о том, что операция была успешно выполнена. Мы двигаемся дальше. Теперь нам необходимо перепроверить в AWS Management Console, что все необходимые ресурсы были созданы. Самое первое - это Demo VPC, совпадает с CIDR block. Далее, у нас есть два subnet, public subnet и private subnet. В public subnet у нас есть дополнительный routing rule, который трафик в интернет направляет через Internet gateway и есть private subnet, у нее трафик в интернет идет через NAT gateway. Здесь все верно. Двигаемся дальше. Есть у нас два route table, один для public subnet и он с ним ассоциирован и то же самое для private subnet, который ассоциирован с private subnet. Далее, у нас есть один Internet gateway, который привязан к нашему Demo VPC. Есть у нас Elastic IP адрес, который используется NAT gateway и собственно сам NAT gateway, который вы видите, у него есть primary public IP адрес, который является Elastic IP адресом. На этом мы выполнили все необходимое в рамках этого задания и фактически все те же ресурсы создали, используя командную строку. На этом мы завершаем сессию Демо. Я надеюсь, что вам стало понятнее принципы работы в AWS CLI. Если будут вопросы, пожалуйста задавайте. На этом спасибо за внимание. Увидимся с вами на следующих наших активностях.