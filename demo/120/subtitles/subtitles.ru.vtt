WEBVTT

00:00:00.000 --> 00:00:06.120
Добрый день, уважаемые студенты!
Я рад вас всех видеть на очередной сессии Демо.

00:00:06.120 --> 00:00:11.146
Сегодня мы с вами проделаем
абсолютно то же задание, что и предыдущее

00:00:11.170 --> 00:00:16.640
Демо, то есть создадим VPC и все ее
необходимые компоненты в облаке AWS.

00:00:16.640 --> 00:00:21.948
Отличие лишь в том, что мы будем для
этого использовать не AWS Management

00:00:21.972 --> 00:00:27.280
Console, а AWS CLI, то есть командную
строку для работы с облаком AWS.

00:00:27.280 --> 00:00:34.400
Итак, давайте начнем.
Давайте вспомним какое же было задание.

00:00:34.400 --> 00:00:42.680
Необходимо было в AWS аккаунте создать
в регионе North Virginia, это us-east-1 VPC.

00:00:42.680 --> 00:00:48.400
VPC будет называться DEMO_VPC
с указанным CIDR блоком.

00:00:48.400 --> 00:00:54.040
Все ресурсы в VPC будут в
одной availability zone это us-east-1a.

00:00:54.040 --> 00:00:58.560
В VPC у нас будет два subnet,
один public, другой private.

00:00:58.560 --> 00:01:01.970
Мы с вами помним, что public
subnet это лишь только название и

00:01:01.994 --> 00:01:06.020
необходимо сделать определенные
шаги, чтобы он фактически стал public.

00:01:06.020 --> 00:01:13.800
Для этого у нас будут отдельные два route table,
один для public subnet, другой для private subnet.

00:01:13.800 --> 00:01:20.680
Мы подключим Internet gateway к VPC, настроим
NAT gateway и поработаем с Elastic IP адресом.

00:01:20.680 --> 00:01:29.200
Все работы мы будем
проводить в sandbox.

00:01:29.200 --> 00:01:35.868
В нижней части списка модулей в AWS
Academy вы можете найти пункт Sandbox и

00:01:35.892 --> 00:01:42.560
если по нему перейдете, будет аналогичный
интерфейс с лабораторной работой.

00:01:42.560 --> 00:01:48.968
Здесь нам необходимо будет открыть
окно Terminal и далее стартовать

00:01:48.992 --> 00:01:55.400
лабораторную работу, чтобы для
нас создался временный AWS account.

00:01:55.400 --> 00:01:59.068
Как только вы ее нажмете
необходимо будет подождать некоторое

00:01:59.092 --> 00:02:02.760
время, после чего статус
лабораторной работы перейдет в Ready.

00:02:02.760 --> 00:02:06.766
Мы можем закрывать это
всплывающее окно и после того как вы

00:02:06.790 --> 00:02:11.280
нажмете на кнопку AWS, вас
направить на AWS Management Console.

00:02:11.280 --> 00:02:17.728
Все команды мы будем вводить
на странице лабораторной работы

00:02:17.752 --> 00:02:24.200
в Terminal, а проверять будем
позже в AWS Management Console.

00:02:24.200 --> 00:02:29.480
Мы начинаем первую часть нашего
Демо и сейчас будем создавать VPC.

00:02:29.480 --> 00:02:33.600
Также разберем определенные
нюансы при работе с командной строкой.

00:02:33.600 --> 00:02:39.280
Самая первая команда - это создание VPC.
VPC без дополнительных компонентов.

00:02:39.280 --> 00:02:43.320
Вы видите команду, давайте
разберем команду по частям.

00:02:43.320 --> 00:02:50.120
Первая часть - это ключевое слово AWS, говорит
о том, что мы начинаем использовать AWS CLI.

00:02:50.120 --> 00:02:58.200
Далее через пробел идет второе ключевое слово
- это название сервиса. В нашем случае это EC2.

00:02:58.200 --> 00:03:05.440
Третье ключевое слово - это название API
или операции. В нашем случае, это Create VPC.

00:03:05.440 --> 00:03:15.089
Далее, вы видите через двойное тире
перечисленные параметры с теми значениями,

00:03:15.113 --> 00:03:25.640
которые мы хотели бы присвоить создаваемому 
ресурсу. В нашем случае мы создаем VPC.

00:03:25.640 --> 00:03:32.440
Первый параметр - это CIDR блок с тем значением,
которое мы видели на картинке в самом начале.

00:03:32.440 --> 00:03:39.400
Далее, второй параметр - это регион. И здесь мы
указываем значение регион North Virginia, us-east-1.

00:03:39.400 --> 00:03:45.120
Как только вы наберете эту команду и
нажмете Enter, вы в ответе получите JSON.

00:03:45.120 --> 00:03:52.160
Этот JSON описывает ресурс, который был создан.
Вы видите, что уже присвоился VPC ID.

00:03:52.160 --> 00:04:01.120
Также видите CIDR блок, который мы с вами
ввели в входных данных и другие метаданные.

00:04:01.120 --> 00:04:07.960
Давайте проверим, что этот VPC действительно
появился и откроем AWS Management Console.

00:04:07.960 --> 00:04:13.540
Здесь нам необходимо воспользоваться
строкой поиска сервисов и начать вводить VPC.

00:04:13.540 --> 00:04:19.440
Как только вы перейдете на нужный сервис, 
проверьте, что вы находитесь в нужном регионе.

00:04:19.440 --> 00:04:25.560
И в левом навигационном меню необходимо
воспользоваться пунктом Your VPCs.

00:04:25.560 --> 00:04:36.440
Вы увидите, что у нас создался VPC с тем же
VPC ID и с CIDR блоком, который мы назначили.

00:04:36.440 --> 00:04:43.600
Давайте теперь удалим этот VPC. Я бы хотел вам
продемонстрировать возможности командной строки.

00:04:43.600 --> 00:04:51.840
Нам необходимо будет подтвердить удаление VPC и
увидеть сообщение, что VPC действительно удалено.

00:04:51.840 --> 00:04:59.448
Мы теперь обратно переходим в
командную строку и вы видите здесь, что мы

00:04:59.472 --> 00:05:07.080
результат работы команды, которая
создает VPC, присваиваем переменные.

00:05:07.080 --> 00:05:13.240
Обратите внимание, у нас добавились дополнительные
параметры. Это output, которое равно текст.

00:05:13.240 --> 00:05:17.280
То есть он в виде текста возвращает
результат работы команды.

00:05:17.280 --> 00:05:26.520
И второй это query, то есть фильтрация. Мы хотим 
в ответе вернуть значение по пути Vpc.VpcId.

00:05:26.520 --> 00:05:32.520
И это значение присвоить
переменной vpc_id.

00:05:32.520 --> 00:05:40.320
Как только команда отработает, можем попробовать
вывести на экран значение переменной VPC ID.

00:05:40.320 --> 00:05:46.568
Вы увидите, что мы получили
другой уникальный VPC ID, но

00:05:46.592 --> 00:05:52.840
с теми же параметрами,
которые мы указывали в команде.

00:05:52.840 --> 00:05:56.068
Давайте теперь перейдем
обратно в AWS Management Console

00:05:56.092 --> 00:05:59.320
и проверим, что действительно
все корректно отработало.

00:05:59.320 --> 00:06:04.400
Мы видим, что CIDR блок тот, который
мы указывали, и совпадает VPC ID.

00:06:04.400 --> 00:06:10.098
Отличие этого действия от предыдущего
в том, что в командной строке мы уже

00:06:10.122 --> 00:06:16.680
сохранили VPC ID в переменной и можем
его использовать в следующих наших командах.

00:06:16.680 --> 00:06:23.598
Это исключает необходимость
ввода различных ID-шников, исключает

00:06:23.622 --> 00:06:32.080
человеческий фактор и упрощает работу
с облаком AWS через командную строку.

00:06:32.080 --> 00:06:37.908
Мы возвращаемся обратно в
командную строку и давайте здесь

00:06:37.932 --> 00:06:43.760
попробуем заполнить тег с
ключом Name, значением Demo VPC.

00:06:43.760 --> 00:06:49.400
Для этого воспользуемся следующей командой.
Мы воспользуемся сервисом EC2.

00:06:49.400 --> 00:06:54.640
Далее у нас есть API Create
Tags и следующие параметры.

00:06:54.640 --> 00:07:00.440
Обратите внимание, что для параметра
Resources мы передаем нашу переменную VPC ID.

00:07:00.440 --> 00:07:05.668
И в параметре Tags мы передаем
в определенном формате, что

00:07:05.692 --> 00:07:10.920
для тега с ключом Name мы хотим
присвоить значение Demo VPC.

00:07:10.920 --> 00:07:14.546
Как только вы запустите эту
команду, если она не вернет

00:07:14.570 --> 00:07:18.600
ошибку, это говорит о том, что
команда успешно отработала.

00:07:18.600 --> 00:07:24.350
Теперь, если мы вернемся обратно в
AWS Management Console, мы увидим,

00:07:24.374 --> 00:07:30.040
что столбец Name для нашего VPC
заполнился, ее значение Demo VPC.

00:07:30.040 --> 00:07:34.728
Отлично, мы с вами возвращаемся
обратно в командную строку

00:07:34.752 --> 00:07:39.440
и здесь я хотел бы обратить
ваше внимание на следующее.

00:07:39.440 --> 00:07:46.680
Наличие тегов в ресурсе позволяет нам фильтровать
и запрашивать метаданные об этих ресурсах.

00:07:46.680 --> 00:07:52.141
Пример, мы можем сейчас
получить информацию о нашем VPC,

00:07:52.165 --> 00:07:58.720
отфильтровав его по тегу Name и
по совпадению значения Demo VPC.

00:07:58.720 --> 00:08:03.432
Для этого воспользуемся API
describe VPCs и введем параметр

00:08:03.456 --> 00:08:07.760
в определенном формате,
который называется filters.

00:08:07.760 --> 00:08:11.240
В результате вы видите,
нам вернулась JSON.

00:08:11.240 --> 00:08:20.760
Есть единственный ключ VPCs, это массив из JSON 
и каждый JSON описывает определенный ресурс.

00:08:20.760 --> 00:08:26.868
Так как мы в фильтрах указали
определенный конкретный VPC,

00:08:26.892 --> 00:08:33.000
то и в массиве был возвращен
один JSON и описывает наш VPC.

00:08:33.000 --> 00:08:37.877
Здесь бы я также хотел обратить
ваше внимание, что работая с

00:08:37.901 --> 00:08:43.276
командной строкой, вы не только
пишете независимые друг от друга

00:08:43.300 --> 00:08:48.376
команды, это не только про
присваивание значений переменным и

00:08:48.400 --> 00:08:54.240
работе с этими переменными, вы
можете писать отдельные bash скрипты.

00:08:54.240 --> 00:08:58.928
Идея в том, что все эти команды
могут быть объединены в одном

00:08:58.952 --> 00:09:03.640
определенном файле и этот файл
выполняет определенную задачу.

00:09:03.640 --> 00:09:06.920
Не маленькую, это не одна команда,
это набор из нескольких команд.

00:09:06.920 --> 00:09:10.486
В тот момент, когда вы
запускаете этот bash скрипт, то

00:09:10.510 --> 00:09:14.480
последовательно выполняются
все команды из этого скрипта.

00:09:14.480 --> 00:09:19.648
Таким образом, вы через bash
скрипты можете определенную часть

00:09:19.672 --> 00:09:24.840
своей ежедневной работы, работы
Cloud инженера автоматизировать.

00:09:24.840 --> 00:09:29.549
Там также вы можете использовать
переменные, более того, вы можете использовать

00:09:29.573 --> 00:09:34.160
более сложные конструкции, то есть
циклы, if else конструкции и так далее.

00:09:34.160 --> 00:09:40.760
В рамках нашего Демо мы с вами
будем использовать простой вариант.

00:09:40.760 --> 00:09:46.962
Написание bash скриптов не входит в
рамках темы нашего Демо, поэтому мы

00:09:46.986 --> 00:09:53.188
будем писать независимые команды, но
при этом максимально будем стараться

00:09:53.212 --> 00:09:59.151
не привязываться к конкретным
значениям, а значение ID-шники ресурсов

00:09:59.175 --> 00:10:05.640
будем присваивать переменным, чтобы
потом их можно было переиспользовать.

00:10:05.640 --> 00:10:12.320
Мы двигаемся к следующим компонентам нашего
VPC и первым делом создадим Internet gateway.

00:10:12.320 --> 00:10:15.520
Для этого мы воспользуемся
следующей командой.

00:10:15.520 --> 00:10:24.040
Здесь сохраним значения по пути InternetGateway.
InternetGatewayId в переменную ig_id.

00:10:24.040 --> 00:10:31.064
Вы видите, после исполнения
команды, мы вывели на экран значение

00:10:31.088 --> 00:10:38.000
в переменной ig_id и здесь
отображается ID Internet Gateway.

00:10:38.000 --> 00:10:45.920
Также можем перепроверить в AWS Management Console
такой же ID, он появился в списке Internet Gateway.

00:10:45.920 --> 00:10:54.360
Теперь нам необходимо для этого Internet Gateway
заполнить тег с ключом Name значение Demo IGW.

00:10:54.360 --> 00:11:02.508
Запускается абсолютно та же команда, которую
мы запускали ранее, отличие лишь в том, что в

00:11:02.532 --> 00:11:10.680
параметр Resources мы передаем ID Internet 
Gateway. Оно у нас сохранено в переменной ig_id.

00:11:10.680 --> 00:11:14.513
Как только мы это сделаем,
вы можете вернуться в AWS

00:11:14.537 --> 00:11:19.200
Management Console и проверить,
что оно успешно применилось.

00:11:19.200 --> 00:11:24.560
Двигаемся дальше. Созданный Internet
Gateway теперь нам необходимо привязать к VPC.

00:11:24.560 --> 00:11:30.440
Для этого есть API
Attach Internet Gateway.

00:11:30.440 --> 00:11:35.280
Обязательными параметрами
являются Internet Gateway и VPC ID.

00:11:35.280 --> 00:11:42.057
Что тот, что этот у нас сохранены в наших
переменных, поэтому мы соответственно для

00:11:42.081 --> 00:11:49.520
Internet Gateway ID указываем значение
переменной ig_id, а для VPC ID переменной vpc_id.

00:11:49.520 --> 00:11:56.788
После того, как вы запустите
команду, в случае если не было выдано

00:11:56.812 --> 00:12:04.080
ошибки, то мы предполагаем, что
команда была выполнена успешно.

00:12:04.080 --> 00:12:08.920
Теперь мы двигаемся дальше.
Мы будем создавать subnets.

00:12:08.920 --> 00:12:20.120
Первым делом необходимо проверить действительно
ли availability zone us-east-1a существует.

00:12:20.120 --> 00:12:30.637
На самом деле это очевидно, мы знаем системное
название региона это us-east-1 и далее мы знаем, что

00:12:30.661 --> 00:12:42.360
availability zone, если их три, то они обозначаются
в алфавитном порядке. Это us-east-1a, 1b и 1c.

00:12:42.360 --> 00:12:48.722
Идея этой команды была в том, что
вы можете внутри программы заложить

00:12:48.746 --> 00:12:54.640
запрос существующих availability
zone для указанного региона.

00:12:54.640 --> 00:13:02.591
В этом случае как value вы указываете не
us-east-1a, а us-east-1 и тогда вам вернется в ответе

00:13:02.615 --> 00:13:11.080
массив availability zone с JSON, в которых будет
содержаться информация каждой availability zone.

00:13:11.080 --> 00:13:18.108
Так как мы отфильтровали по нужной нам
availability zone и в ответе что-то вернулось,

00:13:18.132 --> 00:13:25.160
мы для себя дополнительно подтвердили,
что написание этой availability zone верное.

00:13:25.160 --> 00:13:27.680
Теперь мы будем
создавать public subnet.

00:13:27.680 --> 00:13:32.270
Я не буду детально останавливаться
на частях команды, так

00:13:32.294 --> 00:13:37.460
как идея она абсолютно такая
же, что и в предыдущих командах.

00:13:37.460 --> 00:13:40.520
А предыдущие команды мы с
вами уже подробно разобрали.

00:13:40.520 --> 00:13:44.406
Здесь мы будем использовать
API create subnet, введем

00:13:44.430 --> 00:13:49.440
необходимые параметры это
availability zone, CIDR block и VPC ID.

00:13:49.440 --> 00:14:00.280
Далее это все мы присваиваем переменной.
Нужно нам значение по пути Subnet.SubnetId.

00:14:00.280 --> 00:14:08.040
Мы сразу проверяем значение в переменной
public_subnet_id. Есть некоторая ID. Отлично.

00:14:08.040 --> 00:14:15.120
Двигаемся дальше. Теперь нам необходимо
для этого subnet заполнить тег с ключом name.

00:14:15.120 --> 00:14:20.080
Заполним значением Demo Public Subnet.
Переходим к следующему шагу.

00:14:20.080 --> 00:14:25.520
Теперь нам необходимо создать
NAT gateway в нашем public subnet.

00:14:25.520 --> 00:14:30.600
Для этого в первую очередь нам
необходимо создать Elastic IP address.

00:14:30.600 --> 00:14:37.800
У нас есть отдельный API для создания
Elastic IP адресов. Называется Allocate address.

00:14:37.800 --> 00:14:44.304
Здесь мы дополнительных
параметров не указываем, а лишь

00:14:44.328 --> 00:14:52.280
сохраняем в переменную eip
значение в JSON по пути AllocationId.

00:14:52.280 --> 00:14:58.200
Вы видите, что в переменной
eip появился ID elastic IP адреса.

00:14:58.200 --> 00:15:02.400
Теперь мы можем двигаться дальше,
а именно создадим NAT gateway.

00:15:02.400 --> 00:15:06.920
В этом случае мы используем
API create NAT gateway.

00:15:06.920 --> 00:15:16.228
Передаем сюда параметры
subnet ID, allocation ID и сохраняем

00:15:16.252 --> 00:15:25.560
значение по пути
Natgateway.NatgatewayId в параметр ngw_id.

00:15:25.560 --> 00:15:31.766
Следующий шаг, чтобы сделать наш
subnet фактически public, нам необходимо

00:15:31.790 --> 00:15:38.600
создать route table и в этом route table
произвести дополнительные настройки.

00:15:38.600 --> 00:15:47.628
Итак, для создания route table мы воспользуемся
API create route table, вводим параметры VPC ID и

00:15:47.652 --> 00:15:56.680
как результат в переменной public_rt сохраняем
значение из JSON по пути RouteTable.RouteTableId.

00:15:56.680 --> 00:16:01.040
Мы видим, что в переменную
записалось некоторое значение. Отлично.

00:16:01.040 --> 00:16:09.646
Теперь следующим шагом мы заполним
тег с ключом name, значение будет Public

00:16:09.670 --> 00:16:18.160
Subnet RouteTable и теперь для
нашего route table добавим routing rule.

00:16:18.160 --> 00:16:25.182
Как мы с вами помним, нам нужно
добавить routing rule, который как destination

00:16:25.206 --> 00:16:31.680
использует интернет и как target у
нас используется Internet gateway.

00:16:31.680 --> 00:16:37.240
Соответственно, мы заполняем
параметры destination cidr block и gateway ID.

00:16:37.240 --> 00:16:51.040
Как только мы это все проделаем, мы получим ответ
в виде JSON, где ключ Return заполнен значением true.

00:16:51.040 --> 00:16:57.163
Мы сейчас создали все необходимые routing
rule, теперь не забываем, что route table это

00:16:57.187 --> 00:17:03.880
отдельно независимый ресурс и чтобы он
использовался, необходимо его привязать к subnet.

00:17:03.880 --> 00:17:09.208
Мы помним, что у каждого subnet
может быть привязан только один route

00:17:09.232 --> 00:17:14.560
table, но любой route table может
использоваться несколькими subnet.

00:17:14.560 --> 00:17:19.288
Окей, дальше мы будем
использовать API associate route

00:17:19.312 --> 00:17:24.040
table, здесь укажем
параметр route table и subnet ID.

00:17:24.040 --> 00:17:30.229
После того как мы это сделаем,
мы увидим в ответе JSON, где у нас

00:17:30.253 --> 00:17:37.120
создалась ассоциация, у нее есть
тоже ресурс ID, видите ее на экране.

00:17:37.120 --> 00:17:44.600
То, что мы не получили ошибку, говорит о
том, что операция была успешно выполнена.

00:17:44.600 --> 00:17:52.880
Мы добрались до третьей части нашего Демо и будем
создавать компоненты, связанные с private subnet.

00:17:52.880 --> 00:17:56.240
Первым делом нам необходимо
создать этот subnet ID.

00:17:56.240 --> 00:18:01.568
Вы видите команду, мы используем
API create subnet, указываем availability

00:18:01.592 --> 00:18:06.920
zone, CIDR block, VPC ID и это все
сохраняем в переменную private_subnet_id.

00:18:06.920 --> 00:18:12.800
Из JSON мы используем
значение по пути Subnet.SubnetId.

00:18:12.800 --> 00:18:17.480
Далее мы видим, что в переменной
private_subnet_id появилось значение.

00:18:17.480 --> 00:18:27.680
Теперь нам необходимо для созданного
subnet ID заполнить значение ключ name.

00:18:27.680 --> 00:18:36.120
Для этого воспользуемся API create
tags и введем параметры resources и tags.

00:18:36.120 --> 00:18:43.007
Далее нам необходимо создать route table,
это будет private route table, используем API

00:18:43.031 --> 00:18:50.560
create route table, заполняем параметры VPC
ID, у нас есть уже значение в переменной vpc_id.

00:18:50.560 --> 00:19:00.248
Далее необходимо протегать этот route table, чтобы
мы могли его различать. Значением тега с ключом

00:19:00.272 --> 00:19:09.960
name будет private subnet route table и здесь
необходимо произвести два изменения в route table.

00:19:09.960 --> 00:19:14.788
Первое - это ввести routing
rule, который трафик в интернет

00:19:14.812 --> 00:19:19.640
будет пропускать через
созданный нами ранее NAT gateway.

00:19:19.640 --> 00:19:23.580
ID NAT gateway у нас
хранится в переменной ngw_id.

00:19:23.580 --> 00:19:30.542
Как только мы запустим эту команду,
мы увидим в результате JSON, где ключ

00:19:30.566 --> 00:19:38.400
Return присвоено значение true.
Это значит, что routing rule был успешно создан.

00:19:38.400 --> 00:19:43.520
Теперь нам необходимо этот
route table привязать к private subnet.

00:19:43.520 --> 00:19:52.248
Для этого воспользуемся API associate route
table, заполним route table ID, который хранится

00:19:52.272 --> 00:20:01.000
в переменной private_rt и subnet ID, значение
нужное лежит в переменной private_subnet_id.

00:20:01.000 --> 00:20:06.727
В результате мы увидим ответ в виде
JSON, где ключ association ID заполним

00:20:06.751 --> 00:20:12.320
некоторым ID, что говорит о том, что
операция была успешно выполнена.

00:20:12.320 --> 00:20:16.988
Мы двигаемся дальше. Теперь нам
 необходимо перепроверить в AWS

00:20:17.012 --> 00:20:21.680
Management Console, что все
необходимые ресурсы были созданы.

00:20:21.680 --> 00:20:25.960
Самое первое - это Demo VPC, 
совпадает с CIDR block.

00:20:25.960 --> 00:20:30.080
Далее, у нас есть два subnet,
public subnet и private subnet.

00:20:30.080 --> 00:20:35.728
В public subnet у нас есть дополнительный
routing rule, который трафик в интернет направляет

00:20:35.752 --> 00:20:41.400
через Internet gateway и есть private subnet, у
нее трафик в интернет идет через NAT gateway.

00:20:41.400 --> 00:20:44.720
Здесь все верно.
Двигаемся дальше.

00:20:44.720 --> 00:20:50.928
Есть у нас два route table, один для
public subnet и он с ним ассоциирован

00:20:50.952 --> 00:20:57.160
и то же самое для private subnet,
который ассоциирован с private subnet.

00:20:57.160 --> 00:21:03.400
Далее, у нас есть один Internet gateway,
который привязан к нашему Demo VPC.

00:21:03.400 --> 00:21:13.028
Есть у нас Elastic IP адрес, который используется
NAT gateway и собственно сам NAT gateway,

00:21:13.052 --> 00:21:22.680
который вы видите, у него есть primary public
IP адрес, который является Elastic IP адресом.

00:21:22.680 --> 00:21:28.281
На этом мы выполнили все
необходимое в рамках этого задания и

00:21:28.305 --> 00:21:34.560
фактически все те же ресурсы
создали, используя командную строку.

00:21:34.560 --> 00:21:43.240
На этом мы завершаем сессию Демо. Я надеюсь,
что вам стало понятнее принципы работы в AWS CLI.

00:21:43.240 --> 00:21:47.560
Если будут вопросы, пожалуйста задавайте.
На этом спасибо за внимание.

00:21:47.560 --> 00:21:51.840
Увидимся с вами на
следующих наших активностях.