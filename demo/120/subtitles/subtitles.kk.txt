Қайырлы күн, құрметті студенттер! Барлығыңызды келесі Демо сессияда көргеніме қуаныштымын. Бүгін алдыңғы Демодағы тапсырманы орындаймыз, яғни AWS бұлтында VPC және оның барлық қажетті құрамдастарын жасаймыз. Жалғыз айырмашылық мынада, бұл үшін AWS Management Console емес, AWS CLI, яғни AWS бұлтымен жұмыс істеуге арналған командалық жолын қолданамыз. Ендеше, бастайық. Қандай тапсырма болғанын еске түсірейік. North Virginia аймағында AWS аккаунтын жасау қажет болды, бұл us-east-1 VPC. VPC - DEMO_VPC деп аталады, оның берілген CIDR блогы бар. VPC-дегі барлық ресурстар бір availability zone-да болады, us-east-1a. VPC-де екі subnet болады, біреуі public, екіншісі private. Public subnet тек жай атау екенін және оның шын мәнінде public болуы үшін белгілі бір қадамдар жасалуы керек екенін есте ұстаймыз. Ол үшін екі бөлек route table болады, біреуі public subnet үшін, екіншісі private subnet-ке арналған. Internet gateway-ді VPC-ге қосамыз, NAT gateway баптаймыз және Elastic IP мекенжайымен жұмыс істейміз. Барлық жұмыстарды құмсалғышта орындаймыз. AWS Academy-де модульдер тізімінің төменгі жағында Sandbox пунктін таба аласыз және оны бассаңыз, зертханалық жұмыспен ұқсас интерфейс болады. Мұнда Terminal терезесін ашып, зертханалық жұмысты бастау керек, осылайша уақытша AWS аккаунты жасалады. Оны басқаннан кейін біраз күту керек, содан кейін зертханалық жұмыстың күйі Ready күйіне ауысады. Бұл қалқымалы терезені жаба аламыз және AWS батырмасын басқаннан кейін AWS Management Console бағытталасыз. Барлық командаларды Terminal-дағы зертханалық жұмыстың парақшасында енгіземіз және кейінірек AWS Management Console-де тексереміз. Демоның бірінші бөлігін бастаймыз және енді VPC жасаймыз. Сондай-ақ, команда жолымен жұмыс істегенде белгілі бір нюанстарды қарастырамыз. Ең бірінші команда - VPC жасау. Қосымша компоненттерсіз VPC. Команданы көріп тұрсыздар, оны бөліп қарастырайық. Бірінші бөлігі - AWS кілт сөзі, ол біз AWS CLI пайдалана бастайтынымызды айтады. Әрі қарай екінші кілт сөз – бұл сервис атауы. Біздің жағдайда, бұл - EC2. Үшінші кілт сөз - API немесе операцияның атауы. Біздің жағдайда, бұл - Create VPC. Содан кейін жасалған ресурсқа тағайындағымыз келетін мәндері бар қос сызықша арқылы тізімделген параметрлерді көресіз. Біздің жағдайда біз VPC жасаймыз. Бірінші параметр - бұл ең басында суретте көрген мәні бар CIDR блогы. Келесі, екінші параметр - аймақ. Мұнда North Virginia аймағын, us-east-1 аймағын көрсетеміз. Осы команданы теріп, Enter пернесін басқаннан кейін жауапта JSON аласыз. Бұл JSON жасалған ресурсты сипаттайды. VPC ID тағайындалғанын көресіз. Сондай-ақ, кіріс деректеріне енгізген CIDR блогын және басқа метадеректерді көресіз. Енді осы VPC шынымен пайда болғанын тексеріп, AWS Management Console-ді ашайық. Мұнда сервисті іздеу жолағын пайдаланып, VPC деп енгізуді бастауымыз керек. Дұрыс сервиске кіргеннен кейін, дұрыс аймақта екеніңізді тексеріңіз. Сол жақ шарлау мәзірінде Your VPCs пунктін пайдалану керек. Бірдей VPC ID және біз тағайындаған CIDR блогы бар VPC жасағанымызды көресіз. Енді осы VPC-ні жояйық. Мен сізге командалық жолдың мүмкіндіктерін көрсеткім келеді. VPC жоятынымызды растауымыз керек және VPC шынымен жойылғаны туралы хабарды көруіміз керек. Енді команда жолына ораламыз және VPC жасайтын командаға айнымалы мәндерді тағайындаймыз. Бірақ қосымша параметрлер қосылатынын ескеріңіз. Бұл мәтінге тең болатын output. Яғни, ол команда нәтижесін мәтін түрінде қайтарады. Ал екіншісі - query, яғни фильтр. Жауапта Vpc.VpcId жолындағы мәнді қайтарғымыз келеді. Бұл мәнді vpc_id айнымалысына тағайындаңыз. Әрі қарай, команда аяқталғаннан кейін, VPC ID айнымалысының мәнін көрсетеміз. Сіз басқа бірегей VPC ID алғанымызды көресіз, бірақ командада көрсетілген параметрлермен бірдей. Енді AWS Management Console-ге оралып, барлығының дұрыс жұмыс істегенін тексерейік. CIDR блогы біз көрсеткен блок екенін және VPC ID сәйкес келетінін көреміз. Бұл әрекеттің алдыңғысынан айырмашылығы, команда жолында біз VPC ID-ді айнымалы мәнде сақтадық және оны келесі командаларда пайдалана аламыз. Бұл әртүрлі ID енгізу қажеттілігін, адам факторын болдырмайды және команда жолы арқылы AWS бұлтымен жұмыс істеуді жеңілдетеді. Енді команда жолына ораламыз және осы жерде тегті Name кілтімен, Demo VPC мәнімен толтырып көрейік. Ол үшін келесі команданы қолданамыз. EC2 сервисін қолданамыз. Әрі қарай Create Tags API және келесі параметрлер бар. Resources параметрі үшін VPC ID айнымалы мәнін жіберіп жатқанымызды ескеріңіз. Ал Tags параметрінде Name кілті бар тег үшін Demo VPC мәнін тағайындағымыз келетінін белгілі бір форматта жеткіземіз. Осы команданы іске қосқаннан кейін, ол қатені қайтармаса, бұл команда сәтті орындалғанын білдіреді. Енді, егер AWS Management Console-ге оралсақ, VPC үшін Name бағанының толтырылғанын көреміз, оның мәні Demo VPC. Жақсы, команда жолына қайта ораламыз және осы жерде мен назарыңызды келесіге аударғым келеді. Ресурста тегтердің болуы сол ресурстар туралы метадеректерді фильтрлеп, сұрауға мүмкіндік береді. Мысалы, VPC туралы ақпаратты Name тегі және Demo VPC мәні бойынша фильтрлей аламыз. Бұл әрекетті орындау үшін, Describe VPCs API қолданамыз және filters деп аталатын белгілі бір форматтағы параметрді енгіземіз. Нәтижесінде JSON қайтарылғанын көресіз. Жалғыз VPC кілті бар, ол JSON массиві және әрбір JSON белгілі бір ресурсты сипаттайды. Фильтрде белгілі бір VPC көрсеткендіктен, массивте бір JSON қайтарылды және ол біздің VPC сипаттайды. Бұл жерде мен команда жолымен жұмыс істегенде бір-бірінен тәуелсіз командаларды жазып қана қоймай, айнымалыларға мәндерді тағайындау және осы айнымалылармен жұмыс істеу туралы ғана емес, бөлек bash скрипттерін де жазуға болатындығына назар аударғым келеді. Идея мынада: осы барлық командаларды бір нақты файлға біріктіруге болады және бұл файл белгілі бір тапсырманы орындайды. Кішкентай емес, бұл бір команда емес, бірнеше командалардың жиынтығы. Осы bash скриптін іске қосқан кезде, осы скрипттегі барлық командалар дәйекті түрде орындалады. Осылайша, bash скрипттері арқылы сіз күнделікті жұмысыңыздың белгілі бір бөлігін, Cloud инженердің жұмысын автоматтандыруға болады. Онда айнымалыларды да, сонымен қатар күрделірек конструкцияларды, яғни циклдерді, if else конструкцияларды және т.б. қолдануға болады. Демоның аясында біз қарапайым опцияны қолданамыз. Bash скрипттерін жазу біздің Демо аясына кірмейді, сондықтан біз тәуелсіз командаларды жазамыз, бірақ сонымен бірге белгілі бір мәндерге байланбауға тырысамыз және ресурс ID мәндерін айнымалыларға кейінірек қайта пайдалануға болатындай етіп тағайындаймыз. Енді VPC-нің келесі құрамдастарына көшеміз және ең алдымен Internet gateway жасаймыз. Ол үшін келесі команданы қолданамыз. Мұнда InternetGateway.InternetGatewayId жолындағы мәндерді ig_id айнымалысына сақтаймыз. Команданы орындағаннан кейін ig_id айнымалысында мәнді көрсеттік және Internet Gateway ID осы жерде көрсетіледі. AWS Management Console-де сондай ID тексере аламыз, ол Internet Gateway тізімінде пайда болады. Енді осы Internet Gateway үшін тегті Name кілтімен және Demo IGW мәнімен толтыруымыз керек. Алдында іске қосқан дәл сол команда іске қосылды, жалғыз айырмашылығы - біз ID Internet Gateway Resources параметріне береміз. Оны ig_id айнымалысында сақтадық. Мұны орындағаннан кейін, AWS Management Console-ге оралып, оның сәтті қолданылғанын тексеруге болады. Әрі қарай жүрейік. Енді жасалған Internet Gateway-ді VPC-ге байланыстыруымыз керек. Бұл үшін Attach Internet Gateway деп аталатын API бар. Қажетті параметрлер – Internet Gateway және VPC ID. Ол екеуі айнымалыларымызда сақталады, сондықтан біз Internet Gateway ID үшін ig_id айнымалы мәнін және VPC ID үшін vpc_id айнымалы мәнін көрсетеміз. Команданы іске қосқаннан кейін қате болмаса, команда сәтті орындалды деп есептейміз. Енді әрі қарай жүреміз. Біз subnets жасаймыз. Ең алдымен, us-east-1a availability zone шынымен бар-жоғын тексеруіміз керек. Шынында, бұл анық, өйткені аймақтың жүйелік атауы us-east-1 екенін білеміз, availability zone, мысалы, үшеу болса, онда олар алфавиттік тәртіпте белгіленетінін білеміз. Бұл us-east-1a, 1b және 1c. Бұл команданың идеясы бағдарлама ішіндегі белгілі бір аймақ үшін бар availability zone сұрауға болатын еді. Бұл жағдайда value ретінде us-east-1a емес, us-east-1 мәнін көрсетесіз, содан кейін жауап ретінде сізге әрбір availability zone үшін ақпаратты қамтитын JSON бар availability zone массиві қайтарады. Бізге қажет availability zone бойынша фильтрлеп, жауап қайтарылғандықтан, осы availability zone жазылуы дұрыс екенін өзіміз үшін тағы да растадық. Енді public subnet жасаймыз. Мен команданың бөліктері туралы айтпаймын, өйткені идеясы алдыңғы командалардағыдай. Ал алдыңғы командаларды біз егжей-тегжейлі талқылаған болатынбыз. Мұнда Create Subnet API қолданамыз, қажетті параметрлерді енгіземіз: availability zone, CIDR блогы және VPC ID. Содан кейін осының бәрін айнымалыға тағайындаймыз. Бізге Subnet.SubnetId жолындағы мән қажет. Бірден public_subnet_id айнымалы мәніндегі мәнді тексереміз. Бір ID бар. Жақсы. Әрі қарай жүрейік. Енді осы subnet үшін Name кілтімен тегті толтыруымыз керек. Demo public subnet мәнін толтырыңыз. Келесі қадамға көшейік. Енді public subnet-те NAT Gateway жасау керек. Ол үшін ең алдымен Elastic IP address жасау керек. Elastic IP address жасау үшін бөлек API бар. Ол Allocate address деп аталады. Мұнда қосымша параметрлерді көрсетпейміз, тек JSON ішіндегі мәнді AllocationId жолының бойымен eip айнымалысына сақтаймыз. Сіз eip айнымалысында Elastic IP address ID пайда болғанын көресіз. Енді әрі қарай жүре аламыз, NAT gateway жасаймыз. Бұл жағдайда Create NAT gateway API қолданамыз. Мұнда Subnet ID, Allocation ID параметрлерін береміз және мәнді ngw_id параметрінде Natgateway.NatgatewayId жолында сақтаймыз. Келесі қадам, subnet-ті public ету үшін, route table жасап, осы route table-де қосымша параметрлерді жасауымыз керек. Сонымен, route table жасау үшін Create route table API қолданамыз, VPC ID параметрлерін енгіземіз және нәтижесінде JSON мәнін public_rt айнымалысында RouteTable.RouteTableId жолы бойымен сақтаймыз. Айнымалыға белгілі бір мән жазылғанын көреміз. Жақсы. Енді келесі қадам тегті Name кілтімен толтыру болып табылады, мән Public Subnet Route Table болады және енді Route table үшін routing rule қосамыз. Естеріңізге сала кетейік, Destination ретінде Интернет пайдаланатын және Target ретінде Internet gateway пайдаланатын routing rule қосуымыз керек. Тиісінше, Destination, CIDR блогы мен gateway ID параметрлерін толтырамыз. Осының барлығын орындағаннан кейін Return кілті true мәнімен толтырылған JSON түрінде жауап аламыз. Қазір барлық қажетті routing rule жасадық, route table жеке тәуелсіз ресурс екенін ұмытпаймыз және оны пайдалану үшін оны subnet-ке байланыстыру керек. Әрбір subnet-тің онымен байланыстырылған тек бір route table болуы мүмкін екенін есте ұстаймыз, бірақ кез келген route table-ді бірнеше subnet пайдалана алады. Жарайды, келесі Associate route table API қолданамыз, мұнда route table және subnet ID параметрлерін көрсетеміз. Мұны істегеннен кейін жауабында JSON-да қауымдастық құрғанымызды көреміз, оның ID ресурсы да бар, оны экранда көре аласыз. Қате болмаса, операцияның сәтті аяқталғанын білдіреді. Біз Демоның үшінші бөлігіне жеттік және private subnet-ке қатысты құрамдастарды жасаймыз. Ең алдымен, Subnet ID жасауымыз керек. Сіз команданы көресіз, Create Subnet API қолданамыз, availability zone, CIDR блогын, VPC ID көрсетеміз және барлығын private_subnet_id айнымалысында сақтаймыз. JSON жүйесінен Subnet.SubnetId жолындағы мәнді қолданамыз. Содан кейін мән private_subnet_id айнымалысында пайда болғанын көреміз. Енді жасалған Subnet ID үшін Name кілтінің мәнін толтыру керек. Бұл әрекетті орындау үшін Create tags API қолданамыз және resources пен tags параметрлерін енгіземіз. Әрі қарай, route table жасауымыз керек, ол private route table болады, Create route table API қолданамыз, VPC ID параметрлерін толтырамыз, бізде vpc_id айнымалысында мән бар. Әрі қарай, оны оңай ажырату үшін осы route table-ге тег қосуымыз керек. Name кілті бар тегтің мәні private subnet route table болады және бұл жерде route table-де екі өзгеріс енгізу керек. Біріншісі - Интернетке трафикті біз бұрын жасаған NAT gateway арқылы өткізуге мүмкіндік беретін routing rule енгізу. NAT gateway ID ngw_id айнымалысында сақталады. Осы команданы іске қосқаннан кейін Return кілтінде true мәні орнатылған JSON нәтижесін көреміз. Бұл routing rule сәтті жасалғанын білдіреді. Енді осы route table-ді private subnet-ке байланыстыруымыз керек. Ол үшін Associate route table API қолданамыз, private_rt айнымалысында сақталған route table ID және private_subnet_id айнымалысында subnet ID толтырамыз. Нәтижесінде JSON түрінде жауапты көреміз, онда Association ID кілтін кейбір ID енгіземіз, ол операцияның сәтті аяқталғанын көрсетеді. Әрі қарай жалғастырайық. Енді AWS Management Console-де барлық қажетті ресурстардың жасалғанын тексеруіміз керек. Біріншісі - CIDR блогымен сәйкес келетін Demo VPC. Әрі қарай, екі subnet бар, public subnet және private subnet. Public subnet-те Интернетке трафикті Internet gateway арқылы бағыттайтын қосымша routing rule бар және private subnet бар, онда Интернетке трафик NAT gateway арқылы өтеді. Мұнда бәрі дұрыс. Әрі қарай жүрейік. Екі route table бар, біреуі public subnet үшін және ол онымен байланысты, екіншісі private subnet үшін және оған байланысқан. Әрі қарай, Demo VPC-ге қосылған бір Internet gateway бар. NAT gateway пайдаланатын Elastic IP address бар және сіз көріп отырған NAT gateway өзі, оның Elastic IP address болып табылатын primary public IP мекенжайы бар. Осымен осы тапсырма аясында қажет әрекеттердің барлығын аяқтадық және командалық жолын пайдаланып, дәл сол бірдей ресурстарды жасадық. Осымен Демо сессия аяқталды. Сіз AWS CLI сервисін жақсырақ түсіндіңіз деп үміттенемін. Сұрақтарыңыз болса, жазыңыз. Назарларыңызға рахмет. Келесі белсенділіктерде кездескенше.