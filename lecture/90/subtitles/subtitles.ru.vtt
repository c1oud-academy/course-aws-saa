WEBVTT

00:00:00.000 --> 00:00:05.000
Добрый день, уважаемые студенты!
Я рад вас всех видеть на очередной лекции.

00:00:05.000 --> 00:00:13.000
Это начало серии из двух лекций, тема - 
базы данных. Итак, давайте начнем.

00:00:13.000 --> 00:00:17.000
Наша сегодняшняя лекция
состоит из трех частей.

00:00:17.000 --> 00:00:21.988
В первой части мы поговорим про
архитектуру AWS, которую мы развиваем

00:00:22.012 --> 00:00:27.000
в рамках лабораторных работ,
какая часть добавится на этой неделе.

00:00:27.000 --> 00:00:33.000
Далее, во второй части мы рассмотрим все
вопросы, связанные с выбором типа базы данных.

00:00:33.000 --> 00:00:39.000
Какие виды бывают, чем они друг от друга
отличаются, какие есть преимущества и недостатки.

00:00:39.000 --> 00:00:48.000
Далее, в последней части лекции мы поговорим про
сервис Amazon RDS. Это Relational Database Service.

00:00:48.000 --> 00:00:54.000
Также напоминаю, у нас есть дополнительные
активности на этой неделе, это Демо.

00:00:54.000 --> 00:01:04.000
Будем создавать автоматические бэкапы и read
реплику для инстанса RDS. Также есть Guided Lab.

00:01:04.000 --> 00:01:12.000
Здесь мы будем создавать базу данных RDS. Будет
 введение, а также разбор лабораторной работы.

00:01:12.000 --> 00:01:16.764
Мы начинаем первую часть нашей
сегодняшней лекции и поговорим про

00:01:16.788 --> 00:01:22.000
архитектуру в облаке, которую мы
строим в рамках лабораторных работ.

00:01:22.000 --> 00:01:28.000
На этой неделе добавляется Amazon
RDS Primary Instance. Это - база данных.

00:01:28.000 --> 00:01:35.962
Если говорить про бизнес-кейс, use case, то на
предыдущих неделях создали веб-сайт, добавили

00:01:35.986 --> 00:01:45.000
динамичности, добавили возможность оставлять 
заказы. И как мы помним, у нас есть EC2 Instance.

00:01:45.000 --> 00:01:51.000
Внутри этого же EC2 Instance поднята
база данных и все данные в ней сохраняются.

00:01:51.000 --> 00:01:56.000
Если что-то произойдет с этим EC2
Instance, то мы потеряем все данные.

00:01:56.000 --> 00:02:03.557
Это начали постепенно понимать все роли
в рамках нашего бизнес-кейса, начиная от

00:02:03.581 --> 00:02:12.000
Марты, это мама Софии, которая использует
эти данные в целях бухгалтерии и отчетности.

00:02:12.000 --> 00:02:17.488
Также Фрэнк, он использует
эти данные для поиска идей, какое

00:02:17.512 --> 00:02:23.000
количество десертов нужно
испечь, чтобы их все раскупили.

00:02:23.000 --> 00:02:31.000
Либо экспериментировать с новыми видами
продукции, которые бы всем понравились.

00:02:31.000 --> 00:02:35.000
Также есть некоторые
моменты, связанные со Софией.

00:02:35.000 --> 00:02:42.000
Она понимает, что поддерживать базу данных нужно
некоторое время. Периодически выходят обновления.

00:02:42.000 --> 00:02:49.000
Эти обновления нужно применять к базе
данных и это происходит на регулярной основе.

00:02:49.000 --> 00:02:53.102
Более того администрирование базы
данных – это отдельный скилл, отдельная

00:02:53.126 --> 00:02:57.000
роль или должность специалиста,
который постоянно этим занимается.

00:02:57.000 --> 00:03:03.000
Кого-то обучать времени нет,
самой заниматься тоже не получается.

00:03:03.000 --> 00:03:09.391
Поэтому на общем собрании, на встрече,
было решено рассмотреть варианты, как

00:03:09.415 --> 00:03:16.488
можно разгрузить Софию от этих работ, но
так, чтобы все продолжало работать, чтобы

00:03:16.512 --> 00:03:23.244
все было рабочее, сохранялось, чтобы
данные не затерялись, сама база данных была

00:03:23.268 --> 00:03:30.000
высокодоступной, надежной и была
возможность масштабироваться при необходимости.

00:03:36.000 --> 00:03:43.501
Как решение было согласовано
использовать сервис Amazon

00:03:43.525 --> 00:03:52.000
RDS, который подходит ко всем
требованиям наших персонажей.

00:03:52.000 --> 00:03:59.000
И в рамках наших лабораторных работ мы
будем создавать инстанс базы данных Amazon RDS.

00:04:01.000 --> 00:04:05.000
Мы с вами добрались до второй
части нашей сегодняшней лекции.

00:04:05.000 --> 00:04:08.000
И здесь обсудим моменты,
связанные с выбором баз данных.

00:04:10.000 --> 00:04:14.000
Рекомендуется особо
рассмотреть четыре направления.

00:04:14.000 --> 00:04:20.000
И это максимально поможет не ошибиться с
вашим выбором. Первое – это масштабируемость.

00:04:20.000 --> 00:04:25.000
Здесь подразумевается возможность и
необходимость масштабирования вашей базы данных.

00:04:25.000 --> 00:04:29.525
Вы знаете, какой объем баз
данных у вас в начале, как она будет

00:04:29.549 --> 00:04:34.000
расти и какой она будет
потенциально через некоторое время.

00:04:34.000 --> 00:04:44.000
И таким образом вы можете ответить на вопрос, какой
уровень масштабируемости нужен для вашей базы данных.

00:04:44.000 --> 00:04:52.000
Связанный вопрос - какой объем данных
будет протекать через вашу базу данных?

00:04:52.000 --> 00:04:56.988
Далее, второй момент, который
нужно учитывать – это требования к

00:04:57.012 --> 00:05:02.000
хранилищу, то есть насколько
большой должна быть ваша база данных.

00:05:02.000 --> 00:05:08.000
Это размеры в гигабайты, 
в терабайты, может быть в петабайты.

00:05:08.000 --> 00:05:14.765
В зависимости от того, какой объем баз данных
у вас будет в начале либо через какое-то время

00:05:14.789 --> 00:05:22.000
может потенциально стать, вы в самом начале
будете определяться с какой базы данных вы начнете.

00:05:22.000 --> 00:05:27.488
Далее, третье – это какие
именно данные вы будете хранить,

00:05:27.512 --> 00:05:33.000
то есть какой размер объектов
и какой тип этих объектов.

00:05:33.000 --> 00:05:43.000
Это могут быть какие-то числовые значения, строки,
символы и т.д., то есть простые структуры данных.

00:05:43.000 --> 00:05:46.733
Это могут быть некоторые сложные
структуры данных, то есть объекты,

00:05:46.757 --> 00:05:51.000
рисунок объекты в таком же виде
возможно вам нужно хранить в базе данных.

00:05:51.000 --> 00:05:57.000
Может быть вы будете хранить ваши
данные, то есть медиафайлы в базе данных.

00:05:57.000 --> 00:06:07.000
Эти все моменты также нужно
заранее узнать и брать во внимание.

00:06:07.000 --> 00:06:11.000
Последнее направление – это durability,
то есть надежность вашей базы данных.

00:06:11.000 --> 00:06:17.000
Здесь подразумевается data durability, 
data availability и recoverability.

00:06:17.000 --> 00:06:20.000
Давайте остановимся
подробнее на каждом из них.

00:06:20.000 --> 00:06:27.000
Data durability – это то, могут
ли ваши данные быть утеряны.

00:06:27.000 --> 00:06:34.988
Data availability – это может ли получится так,
что данные хранятся, они есть, но в какой-то

00:06:35.012 --> 00:06:43.000
момент ввиду проблем с сетью либо любыми
другими моментами вы не можете обратиться к ним.

00:06:43.000 --> 00:06:48.661
В зависимости от того, насколько критичен
тот или иной момент, вы будете определять

00:06:48.685 --> 00:06:54.000
уровень durability и availability для
вашей базы данных и для ваших данных.

00:06:54.000 --> 00:07:01.488
Далее, есть понятие recoverability –
это как быстро вам необходимо вернуть

00:07:01.512 --> 00:07:09.000
в строй вашу базу данных и с какими
потерями ваш бизнес может смириться.

00:07:09.000 --> 00:07:17.000
Представим, у вас есть ежемесячные бэкапы и
каждый месяц 1 числа вы делаете бэкап базы данных.

00:07:17.000 --> 00:07:21.488
Она у вас хранится, есть.
В случае, если что-то произойдет в середине

00:07:21.512 --> 00:07:26.000
месяца, вы знаете, что вы можете
всегда откатиться на начало месяца.

00:07:26.000 --> 00:07:30.771
Если те данные, которые были с
начала месяца, будут утеряны для вас

00:07:30.795 --> 00:07:36.000
не критично, это и есть тот уровень
recoverability, который вам нужен.

00:07:36.000 --> 00:07:42.488
Если вы говорите, что вам нужны данные
день в день, то есть что-то происходит сегодня

00:07:42.512 --> 00:07:49.000
с базой данных, нам нужно, чтобы мы смогли
восстановить все данные на начало этого дня.

00:07:49.000 --> 00:07:53.000
И не критично, если мы потеряем
данные, созданные сегодня.

00:07:53.000 --> 00:07:59.677
В этом случае от вас потребуются, естественно,
большие финансовые затраты, так как само

00:07:59.701 --> 00:08:07.000
решение усложнится, но будет обеспечивать
тот уровень recoverability, который вам требуется.

00:08:07.000 --> 00:08:14.240
Если же это такой уровень, когда вы
не можете ни одну строчку ваших данных

00:08:14.264 --> 00:08:22.000
потерять, то в этом случае это будет еще дороже.
Сама архитектура усложнится.

00:08:22.000 --> 00:08:29.000
Скорее всего, нужно подключать другие AWS регионы,
чтобы данные реплицировались в несколько регионов.

00:08:29.000 --> 00:08:35.488
В этом случае вы точно ваши данные не
потеряете, но вы осознаете, что вам необходимо

00:08:35.512 --> 00:08:42.000
нести определенные финансовые расходы
на поддержание этой сложной IT-архитектуры.

00:08:42.000 --> 00:08:48.000
Еще один момент, который связан с durability,
это некоторые регуляторные требования.

00:08:48.000 --> 00:08:55.000
Например, вы работаете в финансовой сфере, и
вам необходимо хранить данные в течение 5 лет.

00:08:55.000 --> 00:08:59.988
Поэтому эти данные нужно сохранить
в определенное место, так чтобы это

00:09:00.012 --> 00:09:05.000
было недорого для вас, но при
необходимости вы могли эти данные извлечь.

00:09:05.000 --> 00:09:13.000
Либо такие требования, что вы не
можете потерять данные более чем за 3 дня.

00:09:13.000 --> 00:09:21.488
Тогда вы должны строить свое решение таким образом,
чтобы каждые 2-3 дня производился бэкап данных, и

00:09:21.512 --> 00:09:30.000
вы в любой момент могли вернуться на предыдущую
версию и не нарушить требования регуляторного органа.

00:09:30.000 --> 00:09:37.000
Когда мы говорим про типы базы
данных, то выделяют две большие группы.

00:09:37.000 --> 00:09:41.109
Первая группа - это
Relational database, примерами

00:09:41.133 --> 00:09:46.000
могут быть Microsoft SQL
Server, Oracle Database, MySQL.

00:09:46.000 --> 00:09:54.000
А вторая группа - это Non-relational, примерами
могут быть MongoDB, Cassandra, Redis и другие.

00:09:54.000 --> 00:09:59.000
Давайте теперь подробнее остановимся,
чем они друг от друга отличаются.

00:09:59.000 --> 00:10:06.000
Когда мы говорим Relational database, то это
тот тип баз данных, который появился изначально.

00:10:06.000 --> 00:10:11.000
Он является самым популярным типом
баз данных, его очень легко использовать.

00:10:11.000 --> 00:10:19.000
Есть возможность работать с SQL, то есть Structured
Query Language, самый популярный язык запросов.

00:10:19.000 --> 00:10:31.000
Далее, это тот случай, когда вам нужна целостность
данных, она гарантируется жесткой структурой таблиц.

00:10:31.000 --> 00:10:38.988
Изначально происходит data modeling, вы определяете
какие таблицы есть, какие есть поля у каждой

00:10:39.012 --> 00:10:47.000
из таблиц, как таблицы между собой взаимосвязаны,
и дальнейшее изменение происходит очень сложно.

00:10:47.000 --> 00:10:55.000
Но если правильно определить все в начале, то
очень просто, удобно работать с этими данными.

00:10:55.000 --> 00:11:02.488
За счет этой оптимизации и структуризации
хранения ваших данных, вы будете

00:11:02.512 --> 00:11:10.000
хранить намного меньше данных, чем
если бы хранили одним большим полотном.

00:11:10.000 --> 00:11:14.901
Relational database идеальны,
когда вам нужна жесткая

00:11:14.925 --> 00:11:20.677
структура, они редко меняются,
вам нужна целостность данных,

00:11:20.701 --> 00:11:25.839
вам нет необходимости в
экстремальных операциях записи

00:11:25.863 --> 00:11:31.000
и чтения, также не нужна
большая производительность.

00:11:31.000 --> 00:11:39.000
В противовес этому типу, у нас есть
вторая группа, это Non-relational database type.

00:11:39.000 --> 00:11:44.000
Это тот случай, когда база данных
строится на конкретную задачу.

00:11:44.000 --> 00:11:53.000
Поэтому видов Non-relational database очень много.
Также их часто называют NoSQL databases.

00:11:53.000 --> 00:11:59.065
Они отличаются гибкостью, высокой
масштабируемостью, высокой производительностью

00:11:59.089 --> 00:12:04.000
и различными возможностями
взаимодействия с этой базой данных.

00:12:04.000 --> 00:12:09.000
Не везде SQL поддерживается
в случае NoSQL баз данных.

00:12:09.000 --> 00:12:13.336
Она идеально подходит, если
вам нужно, чтобы ваша база данных

00:12:13.360 --> 00:12:19.000
масштабировалась горизонтально, то
есть это работа с большим объемом данных.

00:12:19.000 --> 00:12:29.000
Также подходит, если традиционные базы данных
вам по тем или иным причинам не совсем подходят.

00:12:29.000 --> 00:12:36.988
И другой момент, если у вас достаточно
высоконагруженные запросы на ваше приложение,

00:12:37.012 --> 00:12:45.000
то Non-relational database могут быть
экономичнее по сравнению с relational database.

00:12:45.000 --> 00:12:54.000
На этом слайде вы видите примеры самых
популярных существующих сервисов баз данных.

00:12:54.000 --> 00:12:58.000
На самом деле их больше, но
они не так часто используются.

00:12:58.000 --> 00:13:07.000
Сервисы поделены на две группы. С левой 
стороны это примеры реляционных баз данных.

00:13:07.000 --> 00:13:12.000
Самый популярный - это Amazon RDS.
Далее идет Amazon Redshift и Amazon Aurora.

00:13:12.000 --> 00:13:20.000
Я напомню, что Amazon Aurora это
in-house разработка от самого AWS.

00:13:20.000 --> 00:13:27.000
И она предлагает свою реляционную базу данных,
построенные на движке MySQL либо PostgreSQL.

00:13:27.000 --> 00:13:35.000
И глобально ничем не отличается от Amazon
RDS, кроме как нативная интеграция AWS.

00:13:35.000 --> 00:13:41.161
Соответственно, это vendor-lock. Но по той же
самой цене мы получаем большую эффективность

00:13:41.185 --> 00:13:47.000
и производительность по сравнению с любой
другой базой данных в сервисе Amazon RDS.

00:13:47.000 --> 00:13:53.000
Поэтому какой вариант для
вас лучше, вы решаете для себя.

00:13:53.000 --> 00:13:59.000
На следующих слайдах мы подробнее
будем говорить именно про сервис Amazon RDS.

00:13:59.000 --> 00:14:04.000
Если мы говорим про нереляционные базы
данных, тоже очень много различных видов.

00:14:04.000 --> 00:14:11.000
Самые популярные из них - это Amazon DynamoDB,
дальше Amazon ElastiCache и Amazon Neptune.

00:14:11.000 --> 00:14:19.000
Среди этой тройки популярные, часто используемые,
это - key-value Database, то есть Amazon DynamoDB.

00:14:19.000 --> 00:14:25.667
И на этих лекциях мы будем
подробнее рассматривать именно

00:14:25.691 --> 00:14:32.000
Amazon DynamoDB из группы
нереляционных баз данных.

00:14:32.000 --> 00:14:36.000
На этом мы подошли к концу второй
части нашей сегодняшней лекции.

00:14:36.000 --> 00:14:44.000
Мы разобрали кейсы, которые важно знать
и учитывать при выборе типа баз данных.

00:14:44.000 --> 00:14:48.988
Далее, мы сделали поверхностное
сравнение, что такое реляционные

00:14:49.012 --> 00:14:54.000
базы данных и чем они отличаются
от нереляционных баз данных.

00:14:54.000 --> 00:15:01.000
А также буквально один слайд был
посвящен существующим сервисам AWS.

00:15:01.000 --> 00:15:05.000
Самые популярные среди них мы
будем рассматривать более подробно.

00:15:05.000 --> 00:15:14.000
Мы с вами начинаем третью часть нашей сегодняшней
лекции и подробнее поговорим про сервис Amazon RDS.

00:15:14.000 --> 00:15:21.000
Amazon RDS – это полностью managed решение,
которое предоставляет вам нереляционные базы данных.

00:15:21.000 --> 00:15:24.658
Перед тем, как мы перейдем
к разбору этого сервиса,

00:15:24.682 --> 00:15:29.000
давайте посмотрим, что же
такое Managed Database Service.

00:15:29.000 --> 00:15:34.000
На этом слайде вы видите
сравнение трех различных баз данных.

00:15:34.000 --> 00:15:39.000
В первом случае - это база данных, которая
размещается на локальном дата-центре.

00:15:39.000 --> 00:15:46.646
В этом случае абсолютно все производится вами,
то есть начиная от организации питания, подключения

00:15:46.670 --> 00:15:54.000
к сети, заканчивая моментами, связанные
непосредственно с приложением, это на ваших плечах.

00:15:54.000 --> 00:15:59.488
В другом случае - это когда вы хостите
вашу базу данных внутри Amazon EC2, то есть

00:15:59.512 --> 00:16:05.000
подняли сервер и там отдельно установили
приложение баз данных и работаете с ней.

00:16:05.000 --> 00:16:10.549
В этом случае часть, которая
связана с физическим присутствием,

00:16:10.573 --> 00:16:16.123
то есть работы, которые происходят
при физическом присутствии

00:16:16.147 --> 00:16:21.101
возле этого сервера, она
передается AWS, даже установка

00:16:21.125 --> 00:16:27.000
операционной системы это тоже в
каком-то смысле на стороне AWS.

00:16:27.000 --> 00:16:31.488
Для вас фактически все готово, вам
достаточно выбрать подходящую для

00:16:31.512 --> 00:16:36.000
вас операционную систему, и она
устанавливается и готова для работы.

00:16:36.000 --> 00:16:41.736
В этом случае вы видите выделены
синим те работы, связанные

00:16:41.760 --> 00:16:47.000
с базами данных, которые
выполняете самостоятельно.

00:16:47.000 --> 00:16:52.498
И третий случай с правой
стороны - это когда у нас managed

00:16:52.522 --> 00:16:57.536
AWS database service, когда
практически все работы,

00:16:57.560 --> 00:17:03.514
связанные с администрированием
и поддержкой работоспособности

00:17:03.538 --> 00:17:08.000
вашей базы данных,
переходит на сторону AWS.

00:17:08.000 --> 00:17:12.634
Вы лишь управляете тем, что
правильно создаете модель данных,

00:17:12.658 --> 00:17:17.988
создаете таблицы, создаете правильные
запросы для вашего приложения,

00:17:18.012 --> 00:17:23.073
то есть занимаетесь всем тем, что
непосредственно связано с вашим

00:17:23.097 --> 00:17:28.000
приложением и оптимизацией
базы данных для вашего приложения.

00:17:28.000 --> 00:17:37.041
Вы видите, что большой объем работ от вас
переходит AWS, на стороне AWS это максимально

00:17:37.065 --> 00:17:48.000
автоматизировано, нет момента, когда происходит
некоторая поломка ввиду человеческого фактора.

00:17:48.000 --> 00:17:52.488
В большинстве случаев это
происходит из-за того, что само железо

00:17:52.512 --> 00:17:57.000
выходит из строя, и это нормально,
к этому нужно быть готовым.

00:17:57.000 --> 00:18:03.000
А все остальное, оно
автоматизировано и работает как часы.

00:18:03.000 --> 00:18:10.000
Вам лишь остается максимально
сконцентрироваться на вашей конкретной бизнес-задаче.

00:18:10.000 --> 00:18:14.265
В случае, когда у вас небольшая
команда, либо команда из

00:18:14.289 --> 00:18:19.488
дорогостоящих специалистов, либо
в случае, когда команда просто не

00:18:19.512 --> 00:18:23.928
успевает заниматься попутными
работами по поддержке вашей

00:18:23.952 --> 00:18:29.000
инфраструктуры, Managed Database
может быть идеальным решением.

00:18:34.000 --> 00:18:40.000
Давайте рассмотрим кейсы,
которые подходят для Amazon RDS.

00:18:40.000 --> 00:18:44.283
В случае, если вы обращаетесь к
вашим данным транзакционно, либо

00:18:44.307 --> 00:18:49.000
есть небольшая простая аналитика,
то можно использовать Amazon RDS.

00:18:49.000 --> 00:18:53.988
Если мы говорим с точки зрения
размера баз данных, все, что до

00:18:54.012 --> 00:18:59.000
терабайта, это подходит для
работы в реляционных баз данных.

00:18:59.000 --> 00:19:03.776
Если говорить про максимально
поддерживаемые размеры баз данных,

00:19:03.800 --> 00:19:08.576
для Amazon Aurora это 64 терабайта,
для MySQL, MariaDB, Oracle и

00:19:08.600 --> 00:19:13.559
Postgres в два раза меньше - это
32 терабайта, и самый маленький -

00:19:13.583 --> 00:19:19.000
это Microsoft SQL Server, который
поддерживает максимум 16 терабайтов.

00:19:21.000 --> 00:19:27.214
Дополнительным преимуществом использования
Amazon RDS является то, что размер хранилища

00:19:27.238 --> 00:19:34.000
может быть увеличен динамически, нет необходимости
для этого останавливать инстанс базы данных.

00:19:35.000 --> 00:19:39.000
Если мы говорим про производительность,
то здесь есть два варианта.

00:19:39.000 --> 00:19:45.274
Первый вариант - это General SSD,
который на 1 гигабайт выделенного

00:19:45.298 --> 00:19:51.000
дает 3 IOPS, то есть 3 Input
Output Operations Per Second.

00:19:51.000 --> 00:19:57.488
Соответственно, если у вас 100 гигабайтов базы
данных, вы перемножаете 3 умноженное на 100, будет

00:19:57.512 --> 00:20:04.000
300, и в этом случае ваша база данных будет
поддерживать 300 IOPS операций, такой объем данных.

00:20:04.000 --> 00:20:18.000
При необходимости оно может увеличиваться
до 3000 IOPS, но это лишь кратковременное.

00:20:18.000 --> 00:20:26.000
То есть если есть такие нагрузки, то Amazon
RDS тоже так же может в этом случае подойти.

00:20:26.000 --> 00:20:33.000
Если у вас нагрузки еще больше, то есть другой
тип хранения, это Provisioned IOPS SSD storage.

00:20:33.000 --> 00:20:40.000
В этом случае оно поддерживает
еще больше операций ввода и вывода.

00:20:44.000 --> 00:20:51.488
Если мы говорим про поддерживаемые
движки в рамках сервиса Amazon RDS,

00:20:51.512 --> 00:20:59.000
то это Microsoft SQL Server, Oracle,
MySQL, Postgres, Aurora и MariaDB.

00:20:59.000 --> 00:21:06.783
Если мы говорим про существующие
типы баз данных, а также семейство

00:21:06.807 --> 00:21:14.000
типов баз данных, то выделяют 3 вида.
Первый это - T family.

00:21:14.000 --> 00:21:24.000
Это тот случай, когда оно подходит для большинства
нагрузок, также называется Burstable instances.

00:21:24.000 --> 00:21:32.988
То есть если у вас в какой-то момент приходит
большая нагрузка, то именно этот тип инстансов

00:21:33.012 --> 00:21:42.000
баз данных могут работать поверх своих характеристик
некоторое время за дополнительную плату.

00:21:42.000 --> 00:21:48.644
Если мы говорим про второе семейство - это
M family, это тот случай, когда ваши нагрузки

00:21:48.668 --> 00:21:56.000
CPU-intensive, то есть требуют больших вычислительных
мощностей, и идет нагрузка на процессор.

00:21:56.000 --> 00:22:02.000
В этом случае вы можете смотреть в
сторону этого семейства типов баз данных.

00:22:02.000 --> 00:22:09.988
Если мы говорим про третье
семейство - это R family, и оно при прочих

00:22:10.012 --> 00:22:18.000
равных условиях содержит в себе
большее количество операционной памяти.

00:22:18.000 --> 00:22:22.833
Это тот случай, когда у вас
есть большие сложные запросы,

00:22:22.857 --> 00:22:27.690
либо большое количество
подключений к вашей базе данных и

00:22:27.714 --> 00:22:32.845
соответственно идет нагрузка
на операционную память.

00:22:32.869 --> 00:22:38.000
В этом случае вы рассматриваете
типы инстансов из этого семейства.

00:22:38.000 --> 00:22:44.572
Давайте рассмотрим один из самых
популярных use case, это когда у вас есть

00:22:44.596 --> 00:22:51.167
приложение, пользователи генерируют
некоторые данные, эти данные доходят до

00:22:51.191 --> 00:22:57.897
вас, например для S3 и там хранятся в
сыром виде, далее происходит некоторая

00:22:57.921 --> 00:23:04.358
обработка этих данных, очистка,
приведение к определенному виду и после

00:23:04.382 --> 00:23:10.954
этого данные уже почищены, вы сохранете
далее в любом месте, например, в S3

00:23:10.978 --> 00:23:17.549
для долгосрочного хранения, а также
эти же данные передаете в datastore, то

00:23:17.573 --> 00:23:24.233
есть сервис Amazon RDS, где эти данные
используются для простейшей аналитики

00:23:24.257 --> 00:23:30.740
и для поиска некоторых важных для
бизнеса выводов на основе этих данных.

00:23:30.740 --> 00:23:36.583
Давайте теперь подробнее ознакомимся с
функционалом Multi-AZ Deployment. Идея в том,

00:23:36.607 --> 00:23:42.380
что это то, что позволяет нам предоставить
высокую доступность наших баз данных.

00:23:42.380 --> 00:23:49.866
Идея в том, что у нас есть регион, в
регионе есть несколько availability zone и с

00:23:49.890 --> 00:23:57.938
включенным функционалом Multi-AZ Deployment
мы выбираем необходимые availability zone

00:23:57.962 --> 00:24:05.729
и Amazon RDS деплоит два инстанса баз
данных, один как основной, другой как standby

00:24:05.753 --> 00:24:13.520
и при необходимости переключает основную
базу данных между этими двумя инстансами.

00:24:13.520 --> 00:24:19.358
Это предоставляет большую доступность,
также дает возможность автоматически

00:24:19.382 --> 00:24:25.140
переключать основной инстанс базы
данных в случае определенных проблем.

00:24:25.140 --> 00:24:30.537
Какие проблемы могут возникнуть,
это если в целом в availability

00:24:30.561 --> 00:24:36.560
zone будут какие-то проблемы, то
происходит автоматический failover.

00:24:36.560 --> 00:24:43.755
Далее, если есть проблемы с сетью, другой
момент, если вдруг выходит из строя процессор

00:24:43.779 --> 00:24:51.560
либо любое другое железо на этом конкретном
сервере, то происходит автоматический failover.

00:24:51.560 --> 00:24:57.080
И последнее, если что-то опять же происходит с
железом, но связанное с хранением ваших данных.

00:24:57.080 --> 00:25:04.032
В этом случае триггерится событие automated
failover и второй инстанс баз данных, который

00:25:04.056 --> 00:25:11.720
standby, становится основным, а второй, который
был основным, он переходит в состояние standby.

00:25:11.720 --> 00:25:18.640
Для приложения это все происходит
прозрачно, так как ссылка endpoint к вашей

00:25:18.664 --> 00:25:26.231
базе данных она не меняется и приложение
после того, как произойдет переключение,

00:25:26.255 --> 00:25:33.035
оно сможет продолжать работать в
том же режиме, как и работал до этого.

00:25:33.059 --> 00:25:39.840
То есть, автоматический failover не
требует от вас ручного вмешательства.

00:25:41.840 --> 00:25:46.187
Другой функционал называется
read replicas, оно используется

00:25:46.211 --> 00:25:50.040
для повышения производительности
ваших баз данных.

00:25:50.040 --> 00:26:00.280
Идея в том, что создается особый вид вашей базы
данных, которая доступна только для операции чтения.

00:26:00.280 --> 00:26:03.320
Через него вы изменять базу
и что-то записывать не можете.

00:26:03.320 --> 00:26:07.912
Когда вы создаете read
replica, вы можете разгрузить

00:26:07.936 --> 00:26:13.520
основную базу данных от тяжелых
либо частых операций чтения.

00:26:13.520 --> 00:26:17.160
Таким образом нагрузка
переходит на read replicas.

00:26:17.160 --> 00:26:25.720
Следует обратить внимание, что
синхронизация между ними асинхронизирована.

00:26:25.720 --> 00:26:29.880
То есть, данные они появляются
не сразу, а с небольшой задержкой.

00:26:29.880 --> 00:26:37.480
Поддерживается этот функционал четырьмя
движками, это mysql, MariaDB, Postgres и Oracle.

00:26:38.480 --> 00:26:43.548
Основные лимиты, которые
есть, это то, что вы можете создать

00:26:43.572 --> 00:26:48.640
максимум 5 read replica на ваш
основной инстанс баз данных.

00:26:48.640 --> 00:26:56.305
Если вам нужна строгая read-after-write
consistency, это когда возможно считать

00:26:56.329 --> 00:27:04.880
данные сразу после ее записи, то вам
необходимо делать чтение из основной баз данных.

00:27:04.880 --> 00:27:11.779
Во всех других случаях, когда допустимо, что
данные будут в рассинхроне некоторое небольшое

00:27:11.803 --> 00:27:19.240
количество времени, обычно менее одной секунды,
 то рекомендуется использовать read replica.

00:27:19.240 --> 00:27:24.646
Одним из частых use case
является создание read replicas для

00:27:24.670 --> 00:27:31.086
разгрузки основной базы данных в
целях использования для приложения и

00:27:31.110 --> 00:27:37.343
создается еще дополнительная
read replica, на котором отрабатывают

00:27:37.367 --> 00:27:43.600
некоторые сложные запросы для
генерации отчетности для руководства.

00:27:43.600 --> 00:27:49.760
Соответственно руководство, получая эти
отчеты, делает некоторые бизнес решения.

00:27:49.760 --> 00:27:58.000
И эти отчеты формируются не в ущерб основным
нагрузкам от ваших пользователей на приложении.

00:27:58.000 --> 00:28:04.040
Пару слов хотелось бы
добавить касательно бэкапов.

00:28:04.040 --> 00:28:09.669
Есть такая опция, есть manual
backup, есть automatic backups, где вы

00:28:09.693 --> 00:28:16.080
настраиваете расписание и по расписанию
создаются бэкапы ваших баз данных.

00:28:16.080 --> 00:28:22.265
Они хранятся в S3 bucket, этот S3 bucket
может находиться в том же регионе, если есть

00:28:22.289 --> 00:28:29.360
необходимость вы можете создавать снапшоты
в S3 bucket в другом регионе для disaster recovery.

00:28:29.360 --> 00:28:35.960
Также вы можете отправлять ваши снапшоты в другой
AWS аккаунт, если того требует ваша бизнес задача.

00:28:35.960 --> 00:28:46.760
Мы с вами подробнее обсудили про самый
популярный сервис реляционных баз данных Amazon RDS.

00:28:46.760 --> 00:28:51.408
Теперь буквально по одному слайду
остановимся на оставшихся двух

00:28:51.432 --> 00:28:56.080
сервисах реляционных баз данных
Amazon Aurora и Amazon Redshift.

00:28:56.080 --> 00:29:02.680
Amazon Aurora это также fully managed
сервис реляционных баз данных.

00:29:02.680 --> 00:29:08.435
Оно было написано командой
AWS для AWS, то есть это нативное

00:29:08.459 --> 00:29:13.920
AWS решение, базируется на
движках MySQL и PostgreSQL.

00:29:13.920 --> 00:29:19.034
Таким образом, существующую
базу данных на MySQL либо Postgres

00:29:19.058 --> 00:29:23.920
вы можете с легкостью
перенести на сервис Amazon Aurora.

00:29:23.920 --> 00:29:32.453
Этот сервис также хорошо подходит для
транзакционных нагрузок, так как эта база данных была

00:29:32.477 --> 00:29:41.010
написана командой AWS, то была соответственно
оптимизирована и вы за ту же цену при прочих

00:29:41.034 --> 00:29:49.273
равных условиях получаете в пять раз более
производительную базу данных по сравнению со

00:29:49.297 --> 00:29:58.880
стандартным MySQL и в три раза производительную
базу данных по сравнению со стандартным PostgreSQL.

00:29:58.880 --> 00:30:08.200
Детали этих тестов можете с легкостью
найти через поисковик написав простой запрос.

00:30:08.200 --> 00:30:17.011
Также следует отметить, что Aurora предоставляет
достаточно высокую durability, то есть надежность

00:30:17.035 --> 00:30:25.760
хранения ваших данных путем сохранения в шести
различных местах в трех различных availability зонах.

00:30:25.760 --> 00:30:32.800
Это достаточно надежное решение и вы с
меньшей долей вероятности потеряете ваши данные.

00:30:32.800 --> 00:30:40.797
Если говорить про возможности
увеличения производительности, мы ранее

00:30:40.821 --> 00:30:49.760
упоминали, что четыре движка Amazon
RDS поддерживают до пяти read replica.

00:30:49.760 --> 00:30:54.623
Если говорить про Aurora, это 
в три раза больше. Вы можете

00:30:54.647 --> 00:31:00.280
создать для одного основного
инстанса Aurora до 15 read replica.

00:31:00.280 --> 00:31:07.080
Таким образом, она может больше масштабироваться
по сравнению с любым другим движком Amazon RDS.

00:31:07.080 --> 00:31:12.008
Но очень важно отметить то, что
при использовании Amazon Aurora

00:31:12.032 --> 00:31:16.720
вы привязываетесь к AWS,
то есть у вас некий vendor lock.

00:31:16.720 --> 00:31:24.099
Если ваша компания изначально решила
двигаться с AWS, есть дополнительные контракты,

00:31:24.123 --> 00:31:31.948
которые дают скидки, либо вы ограничены
вашей командой, которая специализируется на AWS

00:31:31.972 --> 00:31:39.574
и смена облачного провайдера сильно скажется
на производительности вашей команды, да

00:31:39.598 --> 00:31:47.200
и в целом поставит под вопрос существование
вашей компании, то да, вы привязаны к AWS.

00:31:47.200 --> 00:31:49.688
В этом случае ничего страшного нет.
Использовать этот сервис

00:31:49.712 --> 00:31:52.200
и получать все те преимущества,
которые она предоставляет.

00:31:52.200 --> 00:31:59.640
Здесь также хотелось бы отметить, что Amazon
Aurora также существует в serverless варианте.

00:31:59.640 --> 00:32:06.188
Serverless Aurora это когда у вас поднимается
инстанс базы данных и вы с ней работаете,

00:32:06.212 --> 00:32:12.760
в случае, когда на нее нагрузка не идет,
она отключается и вы за это время не платите.

00:32:12.760 --> 00:32:20.548
Таким образом для непостоянных
нагрузок serverless решение от

00:32:20.572 --> 00:32:28.360
Amazon Aurora может быть
идеальным решением в связке с Lambda.

00:32:28.360 --> 00:32:34.662
Как только вы разовьете ваше
приложение, ваш сервис и вы будете

00:32:34.686 --> 00:32:40.989
получать постоянные нагрузки,
то скорее всего вам от Serverless

00:32:41.013 --> 00:32:46.755
Aurora нужно будет переходить
на стандартный deployment и

00:32:46.779 --> 00:32:53.240
таким образом это будет на тот
момент более выгодным решением.

00:32:53.240 --> 00:32:58.788
Следующий сервис - это 
Amazon Redshift. Это тот сервис,

00:32:58.812 --> 00:33:04.360
который предоставляет вам
Data Warehouse, то есть DWH.

00:33:04.360 --> 00:33:11.836
Это то место, где вы можете хранить все ваши
данные и там проводить некоторые аналитические

00:33:11.860 --> 00:33:18.920
расчеты, то есть OLAP нагрузки. Оно специально
 было создано под такой тип нагрузок.

00:33:18.920 --> 00:33:24.920
Также это тот сервис, который может
расширяться до петабайтов размеров.

00:33:24.920 --> 00:33:32.375
Другая особенность является то, что оно
достаточно нативно интегрировано с сервисом

00:33:32.399 --> 00:33:40.400
Amazon S3 и внутри Redshift вы можете
делать запросы на данные в S3, что очень удобно.

00:33:42.400 --> 00:33:47.520
На этом мы подошли к концу третьей
части нашей сегодняшней лекции.

00:33:47.520 --> 00:33:55.480
Мы разобрали, что такое Managed AWS Database Service,
чем он отличается от других вариантов deployment-а.

00:33:55.480 --> 00:33:59.161
Подробнее разобрали сервис Amazon
RDS, какие у него есть особенности

00:33:59.185 --> 00:34:02.480
и какие есть use-кейсы
использования именно этого сервиса.

00:34:02.480 --> 00:34:10.920
Далее по одному слайду мы рассмотрели следующие
по популярности сервисы реляционных баз данных.

00:34:10.920 --> 00:34:17.320
Это Amazon Aurora и Amazon Redshift.
На этом мы завершаем нашу сегодняшнюю лекцию.

00:34:17.320 --> 00:34:24.240
Я надеюсь, вы получили более полное
представление о разобранных нами сервисах AWS.

00:34:24.240 --> 00:34:29.040
Спасибо за внимание.
Увидимся с вами на следующих наших активностях.