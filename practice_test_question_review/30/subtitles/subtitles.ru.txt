Добрый день, уважаемые студенты! Мы с вами начинаем разбор вопроса Practice Test-а. Что дано? Компания планирует хранить некоторые конфиденциальные данные по налогам в AWS. Эти данные не должны быть доступны публично. Более того, доступ к этим данным должен быть доступным только для определенного VPC. Второе требование. Нам необходимо обеспечить, что объекты в этом хранилище должны быть защищены от удаления и перезаписи. Таким образом, должно сохраняться регуляторное требование WORM, то есть write-once-read-many. Идея в том, что записывается один раз и может считываться много раз. Перезаписываться эти объекты тоже не могут. Нам необходимо из предложенных вариантов ответа выбрать два варианта ответа, которые помогают это требование реализовать. Давайте посмотрим, какие варианты ответов нам даны. Мы видим, что первый и четвертый варианты ответов являются правильными. Более того, мы видим, что ни один из вариантов не похож на другой. Таким образом, этот вопрос является достаточно сложным, требует знания нескольких особенностей AWS. Давайте попробуем разобрать каждый из вариантов ответа и дать ответ, почему оно верное или неверное. Давайте вспомним теорию, а именно функционал Access Points сервиса Amazon S3. Это тот функционал, который позволяет ограничить доступ к S3 Bucket на операции с объектами, такие как чтение объекта либо запись объекта. Вы можете видеть на картинке, в левом навигационном меню было выбрано Access Points сервиса Amazon S3 и указываются некоторые входные данные, а именно Bucket. Далее указывается список VPC, на которые ставится ограничение. Из всех других не указанных VPC к этому S3 обратиться будет невозможно. Другой момент это то, что Access Points хорош тем, что не требует выхода в интернет. Все операции обмена данными происходят внутри глобальной инфраструктуры AWS. Это все дает дополнительные возможности, а именно то, что мы можем настроить cross-regional доступ к вашему S3 Bucket через Access Points. Это также возможно. В этом случае используется AWS Global Accelerator, который помогает быстрее передавать ваши данные. Другой функционал, который важен для решения конкретной задачи, это S3 Object Lock. Идея в том, что этот функционал запрещает запись и перезапись объектов внутри нашего S3 Bucket и дает возможность бесконечное количество раз эти объекты считывать. Есть определенные нюансы. Object Lock настраивается в момент создания S3 Bucket. Таким образом, в момент создания вам необходимо в Advanced Settings для опции Object Lock выбрать опцию Enable. Обратите внимание, что когда вы включаете Object Lock, его после отключить будет невозможно. Более того, он автоматически включает Bucket Versioning. Когда у нас включенный Object Lock, Bucket Versioning отключен или остановлен быть не может. Таким образом, правильными ответами являются использование Amazon S3 Access Point для того, чтобы ограничить доступ на конкретный VPC. И второй вариант ответа - это использовать функционал Object Lock во время создания S3 Bucket, для того, чтобы учитывалось регуляторное требование записывать файлы один раз и иметь возможность считывать эти файлы необходимое количество раз. Давайте теперь подробнее остановимся на вариантах ответов, которые являются неверными. В первом случае говорится про AWS Network Firewall. Network Firewall настраивается на уровне VPC, не на уровне S3 Bucket. Таким образом, даже если мы можем настроить поток данных для VPC, ограничить доступ к S3 Bucket через Network Firewall мы не можем. Поэтому этот вариант является неверным. Если мы говорим про вариант S3 Glacier, он также не подходит, потому что Glacier используется для хранения архивных данных и извлечения данных не сразу, а через какое-то время. Нам же сказано, что мы должны иметь возможность при необходимости в ту же секунду извлекать эти данные. Другой момент это то, что Glacier не запрещает перезаписывать или создавать новые файлы. Таким образом, требование WORM, то есть write-once-read-many не выполняется. Если мы говорим про последний вариант с включением опции Object Lock при этом отключить Object Versioning, он сам себя исключает, потому что в момент, когда вы включаете Object Lock, автоматически включается Object Versioning. Его вы отключить или даже остановить после включения опции Object Lock не можете. Поэтому этот вариант является неверным. На этом мы разобрали вопрос Practice Test-а. Спасибо за внимание.